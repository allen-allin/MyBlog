{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/huno/source/css/archive.css","path":"css/archive.css","modified":0,"renderable":1},{"_id":"themes/huno/source/css/china-social-icon.css","path":"css/china-social-icon.css","modified":0,"renderable":1},{"_id":"themes/huno/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/huno/source/css/animate.css","path":"css/animate.css","modified":0,"renderable":1},{"_id":"themes/huno/source/css/uno.css","path":"css/uno.css","modified":0,"renderable":1},{"_id":"themes/huno/source/images/totop.png","path":"images/totop.png","modified":0,"renderable":1},{"_id":"themes/huno/source/js/awesome-toc.min.js","path":"js/awesome-toc.min.js","modified":0,"renderable":1},{"_id":"themes/huno/source/js/jquery.githubRepoWidget.min.js","path":"js/jquery.githubRepoWidget.min.js","modified":0,"renderable":1},{"_id":"themes/huno/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/huno/source/js/scale.fix.js","path":"js/scale.fix.js","modified":0,"renderable":1},{"_id":"themes/huno/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/huno/source/fonts/china-social/china-social.eot","path":"fonts/china-social/china-social.eot","modified":0,"renderable":1},{"_id":"themes/huno/source/fonts/china-social/china-social.svg","path":"fonts/china-social/china-social.svg","modified":0,"renderable":1},{"_id":"themes/huno/source/fonts/china-social/china-social.ttf","path":"fonts/china-social/china-social.ttf","modified":0,"renderable":1},{"_id":"themes/huno/source/fonts/china-social/china-social.woff","path":"fonts/china-social/china-social.woff","modified":0,"renderable":1},{"_id":"themes/huno/source/fonts/china-social/readme.html","path":"fonts/china-social/readme.html","modified":0,"renderable":1},{"_id":"themes/huno/source/fonts/foundation-icons/foundation-icons.css","path":"fonts/foundation-icons/foundation-icons.css","modified":0,"renderable":1},{"_id":"themes/huno/source/fonts/foundation-icons/foundation-icons.eot","path":"fonts/foundation-icons/foundation-icons.eot","modified":0,"renderable":1},{"_id":"themes/huno/source/fonts/foundation-icons/foundation-icons.ttf","path":"fonts/foundation-icons/foundation-icons.ttf","modified":0,"renderable":1},{"_id":"themes/huno/source/fonts/foundation-icons/foundation-icons.woff","path":"fonts/foundation-icons/foundation-icons.woff","modified":0,"renderable":1},{"_id":"themes/huno/source/fonts/foundation-icons/foundation-icons.svg","path":"fonts/foundation-icons/foundation-icons.svg","modified":0,"renderable":1},{"_id":"themes/huno/source/images/881407.jpg","path":"images/881407.jpg","modified":0,"renderable":1},{"_id":"themes/huno/source/images/background-cover.jpg","path":"images/background-cover.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"092c55cba253d220e239fc347c8ca6919febe32e","modified":1481523291964},{"_id":"themes/huno/README.en.md","hash":"0878f26ed7fd9d4cbfeb0ddab5e1e14c93be793a","modified":1481387580647},{"_id":"themes/huno/_config.yml","hash":"745ce3a9b404197a62e20157f1ecfd30bff84753","modified":1481387580649},{"_id":"themes/huno/README.md","hash":"8940f32e649ba30b684f347c04826a066fa9f399","modified":1481387580648},{"_id":"source/_posts/DOM操作-表格排序.md","hash":"f595f6d410af96c6f259e3865a0de5f297166f12","modified":1484665703576},{"_id":"source/_posts/DOM操作-表格的添加删除搜索.md","hash":"abe0ae78542349f0db3531c79d253a2539a96c10","modified":1484665703577},{"_id":"source/_posts/三种三栏式自适应宽度布局.md","hash":"8af09755128225eec1879c58b3d848827aed7591","modified":1484665703578},{"_id":"source/_posts/定时器-图片无缝滚动效果.md","hash":"b6155447629476516fb1b626d7a1a61b03e8f07d","modified":1484665703579},{"_id":"themes/huno/.git/config","hash":"4f38f9c9501d60cfed21ee72138434fbf66db4f5","modified":1481387580641},{"_id":"themes/huno/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1481387580630},{"_id":"themes/huno/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1481387130114},{"_id":"themes/huno/.git/index","hash":"978501b66f4c9aa0e435eafe98aaeeee1d699725","modified":1482985599674},{"_id":"themes/huno/.git/packed-refs","hash":"8647383fb9ce21a528fa4a1338a8f150043e6e13","modified":1481387580624},{"_id":"themes/huno/languages/default.yml","hash":"bddd7fd79412849a52b9a36aae36af111b2db619","modified":1481387580670},{"_id":"themes/huno/languages/zh-CN.yml","hash":"fc0fcc3819c03baeecf2aa51cec08257973288cf","modified":1481387580671},{"_id":"themes/huno/languages/zh-TW.yml","hash":"77d7802d83cdeb2d83937ff947232706efb31956","modified":1481387580671},{"_id":"themes/huno/layout/archive.ejs","hash":"23aff325ab97b2c7dde6e757fa3add5226a88b4f","modified":1481387580679},{"_id":"themes/huno/layout/layout.ejs","hash":"4977031185ae4687c0ba0ec1f7aec5050b203726","modified":1481387580680},{"_id":"themes/huno/layout/index.ejs","hash":"12c817a875f353c03d8795c2a7b653e4da22c17e","modified":1481387580680},{"_id":"themes/huno/layout/page-archive.ejs","hash":"ce5523d829c0fdd6a79984fcf15e33572a220df9","modified":1481387580681},{"_id":"themes/huno/layout/category.ejs","hash":"2b412d1b52b9da8ad19f6a66b1c18ab0b7546214","modified":1481387580679},{"_id":"themes/huno/layout/page.ejs","hash":"70a50ecf7e1aa9c658212f1e77783dcb287d56a6","modified":1481387580681},{"_id":"themes/huno/layout/post.ejs","hash":"86c9d13e8abdcff4d368e34595e2d2f11f37e9d4","modified":1481387580682},{"_id":"themes/huno/layout/tag.ejs","hash":"fefa03bed577cae2e1aac19bd5d30c5034f453a0","modified":1481387580682},{"_id":"themes/huno/layout/_partials/list-posts.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1481387580674},{"_id":"themes/huno/cs-icon.png","hash":"4ba5bfbacb1a533f3561112406c305e9510aa8dd","modified":1481387580652},{"_id":"themes/huno/layout/_scripts/site-analytics.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1481387580678},{"_id":"themes/huno/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1481387130115},{"_id":"themes/huno/.git/hooks/applypatch-msg.sample","hash":"86b9655a9ebbde13ac8dd5795eb4d5b539edab0f","modified":1481387130115},{"_id":"themes/huno/.git/hooks/pre-applypatch.sample","hash":"42fa41564917b44183a50c4d94bb03e1768ddad8","modified":1481387130120},{"_id":"themes/huno/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1481387130120},{"_id":"themes/huno/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1481387130119},{"_id":"themes/huno/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1481387130121},{"_id":"themes/huno/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1481387130121},{"_id":"themes/huno/.git/hooks/update.sample","hash":"39355a075977d05708ef74e1b66d09a36e486df1","modified":1481387130122},{"_id":"themes/huno/.git/hooks/pre-push.sample","hash":"b4ad74c989616b7395dc6c9fce9871bb1e86dfb5","modified":1481387130121},{"_id":"themes/huno/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1481387130123},{"_id":"themes/huno/.git/logs/HEAD","hash":"8a38a68f184c3a9807bd07c2297fef3c00571d91","modified":1481387580636},{"_id":"themes/huno/layout/_partials/archive.ejs","hash":"2c413cde5b1d3a475777e8ff8226762dfe92610c","modified":1481387580672},{"_id":"themes/huno/layout/_partials/article.ejs","hash":"12993f72e718ac81763c2095f64b7ef3523f1777","modified":1482985599341},{"_id":"themes/huno/layout/_partials/disqus.ejs","hash":"30c043cc683c78f345a658cf64b37e55e6521685","modified":1481387580673},{"_id":"themes/huno/layout/_partials/duoshuo.ejs","hash":"7cfe423c088a3bf0565e27a1c17d1b99a260786b","modified":1481387580674},{"_id":"themes/huno/layout/_partials/footer.ejs","hash":"59070ce06159cfd45b13c9499b1e4f0a272d1019","modified":1481387580674},{"_id":"themes/huno/layout/_partials/pagination.ejs","hash":"1240c019aa4df269777c54c0d2124b534ec1f380","modified":1481387580675},{"_id":"themes/huno/layout/_partials/side-panel.ejs","hash":"8d38cb60200b157d24866417686b0479def918de","modified":1481387580675},{"_id":"themes/huno/layout/_partials/social.ejs","hash":"9d40db0aa7f062adab1a0dcfa45c57e2a724ac00","modified":1481387580676},{"_id":"themes/huno/layout/_scripts/awesome-toc.ejs","hash":"b39df57929c246726ca45723ca9ad1a4104738c4","modified":1481387580676},{"_id":"themes/huno/layout/_scripts/github-repo-widget.ejs","hash":"ee64a8e431318cb8fb25f59cfeec0def95b58912","modified":1481387580677},{"_id":"themes/huno/layout/_scripts/killie6.ejs","hash":"2d5db8a53962ac704b8bfc40688319bed2e84ac9","modified":1481387580677},{"_id":"themes/huno/layout/_scripts/mathjax.ejs","hash":"2921f9f3b3c3e40f59c2d023764694a79ac07926","modified":1481387580678},{"_id":"themes/huno/source/css/archive.css","hash":"7238ea5f6bda859e3bae7aaa546caf27fe1fb0cc","modified":1481387580684},{"_id":"themes/huno/source/css/china-social-icon.css","hash":"c4940622efebd76407d722876e05833265da4121","modified":1481387580685},{"_id":"themes/huno/source/css/highlight.styl","hash":"1d11785e5cb56e4a26521da4a3983d9c215baa03","modified":1481387580685},{"_id":"themes/huno/source/css/animate.css","hash":"651fcf046b1bd2bff3ab4cb8947ff7fe058de373","modified":1481387580684},{"_id":"themes/huno/source/css/uno.css","hash":"2abd12d4c71c29d2ee6a8f739e038df0a5f55830","modified":1481524733440},{"_id":"themes/huno/source/images/totop.png","hash":"4f6cb11941e5a72b03cb00cf9d9d55671b4310eb","modified":1481387580728},{"_id":"themes/huno/source/js/awesome-toc.min.js","hash":"f349e6fdbe575f5e0c54425e558b24671f30274b","modified":1481387580729},{"_id":"themes/huno/source/js/jquery.githubRepoWidget.min.js","hash":"94a141fa474ec5022f7c397b4fd3ff92405ab755","modified":1481387580730},{"_id":"themes/huno/source/js/main.js","hash":"4a477bf23afa10929c4be55ab90c59ce0d9b9842","modified":1481387580732},{"_id":"themes/huno/source/js/scale.fix.js","hash":"ce593f56728cc1cedf2e513cb20b926de3b05e07","modified":1481387580733},{"_id":"themes/huno/source/js/jquery.min.js","hash":"8b6babff47b8a9793f37036fd1b1a3ad41d38423","modified":1481387580731},{"_id":"themes/huno/.git/refs/heads/master","hash":"3c4512585bce805b5d221ad0b3f02fb85feb8b65","modified":1481387580634},{"_id":"themes/huno/.git/objects/pack/pack-1bda401722f441011f6a5d8fd4ab2dd21aa48014.idx","hash":"f43638fdc75be119e217c5e33715685f7d3e1938","modified":1481387580530},{"_id":"themes/huno/source/fonts/china-social/china-social.eot","hash":"a43a5c3d66f0d38639a595ebd02857e152ada475","modified":1481387580710},{"_id":"themes/huno/source/fonts/china-social/china-social.svg","hash":"c097f6b54a4883b13ec263f164b79fb2c1981ed3","modified":1481387580710},{"_id":"themes/huno/source/fonts/china-social/china-social.ttf","hash":"2f94360528097df7dcfb39baf8df5393a0d47ca3","modified":1481387580711},{"_id":"themes/huno/source/fonts/china-social/china-social.woff","hash":"74c0ac5268cf7ffe270faaf7c960b74d483d2df1","modified":1481387580712},{"_id":"themes/huno/source/fonts/china-social/readme.html","hash":"8f24e00b8975e09a1e851b45c07a18b382ae08bc","modified":1481387580713},{"_id":"themes/huno/source/fonts/foundation-icons/foundation-icons.css","hash":"426036f1d554b9dffae8b38acc36cade40d9521a","modified":1481387580714},{"_id":"themes/huno/source/fonts/foundation-icons/.fontcustom-data","hash":"3b0cfb3ba2ee7ccae391bc66b3acaa6895932e5f","modified":1481387580713},{"_id":"themes/huno/source/fonts/foundation-icons/foundation-icons.eot","hash":"d584172686583fd510d8f04cf21e6e77fce51435","modified":1481387580715},{"_id":"themes/huno/source/fonts/foundation-icons/foundation-icons.ttf","hash":"4b2bce6c792493a4a5716b6fec2dbefe89492c3f","modified":1481387580719},{"_id":"themes/huno/source/fonts/foundation-icons/foundation-icons.woff","hash":"112fb0e498037f2fea036adb8105e47638159eaa","modified":1481387580720},{"_id":"themes/huno/.git/logs/refs/heads/master","hash":"8a38a68f184c3a9807bd07c2297fef3c00571d91","modified":1481387580635},{"_id":"themes/huno/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1481387580627},{"_id":"themes/huno/source/fonts/foundation-icons/foundation-icons.svg","hash":"bdca38f453f9935203fe8cd071e97d7f8576e0be","modified":1481387580717},{"_id":"themes/huno/.git/logs/refs/remotes/origin/HEAD","hash":"8a38a68f184c3a9807bd07c2297fef3c00571d91","modified":1481387580629},{"_id":"themes/huno/source/images/881407.jpg","hash":"7b2ec4324091ab720827838b497dc4a6ab5ae367","modified":1481524616795},{"_id":"themes/huno/source/images/background-cover.jpg","hash":"08162d5ddd6c081f2713bfd10261e62f0752a600","modified":1481387580727},{"_id":"themes/huno/demo.gif","hash":"cf6121b4aa0f3b07a2f919099942d97206202aa8","modified":1481387580669},{"_id":"themes/huno/.git/objects/pack/pack-1bda401722f441011f6a5d8fd4ab2dd21aa48014.pack","hash":"a6d1197415ef7d58d10b9ce4defaec9ef4402bc8","modified":1481387580559},{"_id":"public/2016/12/09/定时器-图片无缝滚动效果/index.html","hash":"017685cf11fcd053b8ddb9db50f416897ce3f573","modified":1484665797259},{"_id":"public/2016/12/08/DOM操作-表格排序/index.html","hash":"34bc86cd4b6ced95cd9218819dd1934298a86b73","modified":1484665797259},{"_id":"public/archives/index.html","hash":"c86a0adf0b103639aac368c3beff9098f68b28b3","modified":1484666911720},{"_id":"public/archives/2016/index.html","hash":"40721fa27445879c48be6272a9662cd8a6c3b23e","modified":1484666911720},{"_id":"public/archives/2016/12/index.html","hash":"04f224fc20b77603cc19ef2ea868579a8a499205","modified":1484666911721},{"_id":"public/2016/12/10/DOM操作-表格的添加删除搜索/index.html","hash":"59635d716c4bfd18ca5896ea05579ae0b605fb75","modified":1484665797260},{"_id":"public/index.html","hash":"afab1ed3fba13d267f671543372f3e1b445bd3f6","modified":1484666658451},{"_id":"public/tags/学习心得/index.html","hash":"d5fa6b2be7fb1744f2afa1439934743fa4c482d3","modified":1484666911721},{"_id":"public/CNAME","hash":"092c55cba253d220e239fc347c8ca6919febe32e","modified":1484665797266},{"_id":"public/images/totop.png","hash":"4f6cb11941e5a72b03cb00cf9d9d55671b4310eb","modified":1484665797266},{"_id":"public/fonts/china-social/china-social.eot","hash":"a43a5c3d66f0d38639a595ebd02857e152ada475","modified":1484665797266},{"_id":"public/fonts/china-social/china-social.ttf","hash":"2f94360528097df7dcfb39baf8df5393a0d47ca3","modified":1484665797266},{"_id":"public/fonts/china-social/china-social.woff","hash":"74c0ac5268cf7ffe270faaf7c960b74d483d2df1","modified":1484665797267},{"_id":"public/fonts/china-social/china-social.svg","hash":"c097f6b54a4883b13ec263f164b79fb2c1981ed3","modified":1484665797266},{"_id":"public/fonts/foundation-icons/foundation-icons.eot","hash":"d584172686583fd510d8f04cf21e6e77fce51435","modified":1484665797267},{"_id":"public/fonts/foundation-icons/foundation-icons.ttf","hash":"4b2bce6c792493a4a5716b6fec2dbefe89492c3f","modified":1484665797267},{"_id":"public/fonts/foundation-icons/foundation-icons.woff","hash":"112fb0e498037f2fea036adb8105e47638159eaa","modified":1484665797267},{"_id":"public/css/archive.css","hash":"88005d441d52e143cd2ab4da53b1ec50e22f9ade","modified":1484665797759},{"_id":"public/css/highlight.css","hash":"701da6788bee02c165236174b6767ae06957f051","modified":1484665797759},{"_id":"public/css/china-social-icon.css","hash":"2f90442f6d0d289e49c07a85c2dae32cab8b2063","modified":1484665797759},{"_id":"public/js/awesome-toc.min.js","hash":"b4d0f2a33f8340eb2543e8b2cee0dfd745cfb54a","modified":1484665797759},{"_id":"public/js/jquery.githubRepoWidget.min.js","hash":"94a141fa474ec5022f7c397b4fd3ff92405ab755","modified":1484665797759},{"_id":"public/js/main.js","hash":"bafb068e72c56db9e66ac148512b1b21cf5547e1","modified":1484665797760},{"_id":"public/js/scale.fix.js","hash":"bbf62458c63fca2535965f9dfaacfbc6bc697e03","modified":1484665797760},{"_id":"public/fonts/china-social/readme.html","hash":"ca335751de11d6ef7721dc907571de39cef6e361","modified":1484665797760},{"_id":"public/css/uno.css","hash":"a5bc0d3702596198d18a6fa26339ef8ebfed1ee4","modified":1484665797760},{"_id":"public/css/animate.css","hash":"a2f854fbdc52a5657dd5e2b95cc96c0da32f3ea2","modified":1484665797760},{"_id":"public/js/jquery.min.js","hash":"06e872300088b9ba8a08427d28ed0efcdf9c6ff5","modified":1484665797760},{"_id":"public/fonts/foundation-icons/foundation-icons.css","hash":"2ad3bb2b4b7d1d67b4d40a9672193638c168c12a","modified":1484665797760},{"_id":"public/fonts/foundation-icons/foundation-icons.svg","hash":"bdca38f453f9935203fe8cd071e97d7f8576e0be","modified":1484665797760},{"_id":"public/images/881407.jpg","hash":"7b2ec4324091ab720827838b497dc4a6ab5ae367","modified":1484665797776},{"_id":"public/images/background-cover.jpg","hash":"08162d5ddd6c081f2713bfd10261e62f0752a600","modified":1484665797788},{"_id":"public/2016/12/19/三种三栏式自适应宽度布局/index.html","hash":"ef8bea3257d628a90e78e281cf8fd5f6c7dd65ec","modified":1484665797259},{"_id":"source/_posts/循环、迭代、遍历和递归.md","hash":"3d884037003be9003ea4f5cf93842c789867b304","modified":1484665703580},{"_id":"public/2016/12/20/循环、迭代、遍历和递归/index.html","hash":"34fe5443a9a25aba940db57875a7f03d7d721b71","modified":1484665797258},{"_id":"source/_posts/闭包小结.md","hash":"54f477f21f18819b09166552fbdfaae7c5d53690","modified":1484665703580},{"_id":"public/2016/12/20/闭包小结/index.html","hash":"4d907b01b39f4fa05787b0be330aba9c758ea69b","modified":1484665797260},{"_id":"source/_posts/基本类型值和引用类型值.md","hash":"d8b64f910968020b533d462f2fb7bad09bc41842","modified":1484665703579},{"_id":"public/2016/12/23/基本类型值和引用类型值/index.html","hash":"fc7f47cf506777433849d0c38f64fa2af40cdc9e","modified":1482505079504},{"_id":"source/_posts/Function类型小结.md","hash":"062d0e3f96f2ad96b61f07193a56d8fb7dcd19c5","modified":1484665703577},{"_id":"public/2016/12/23/Function类型小结/index.html","hash":"09e9e97216bf045aa186a9e25045fee9898b8aa4","modified":1484665797258},{"_id":"source/_posts/圣杯布局和双飞翼布局.md","hash":"e068e924a859382a497f693ded288d60d4e7252b","modified":1484665703578},{"_id":"public/2016/12/18/圣杯布局和双飞翼布局/index.html","hash":"3c3329d64ca505bd52267bb57400b708929e9063","modified":1484665797259},{"_id":"public/2016/12/22/基本类型值和引用类型值/index.html","hash":"7f5e4e2acb17178737f14889aa5c833ae1105ae6","modified":1484665797258},{"_id":"source/_posts/test.md","hash":"1dfe8a7d161f535b1ed9d15687d9d1262835249a","modified":1484666482189},{"_id":"public/2017/01/17/test/index.html","hash":"74085a7fdc1205de074317da068bc303ed86ae9a","modified":1484665797258},{"_id":"public/archives/2017/index.html","hash":"d255327aa5397eecf8709b1ec8a21bb95122dc87","modified":1484665797259},{"_id":"public/archives/2017/01/index.html","hash":"1c4c56cdf011a4ef394dcc516dbb05febe4c3347","modified":1484665797260},{"_id":"public/2016/12/22/test/index.html","hash":"257df967decedd91a86e9695ba8892f959bf76e6","modified":1484666658451}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"定时器-图片无缝滚动效果","date":"2016-12-09T06:20:49.000Z","_content":"# 用定时器实现图片无缝滚动效果\n### 效果思路\n1.布局：div>ul>li*4>img\n* div必须为相对定位，隐藏溢出\n* ul必须为绝对定位\n* 图片的宽高可自己规定\n\n2.实现无缝滚动的原理：所有的图片都看起来不能出div，div要随时保持有图片\n* 必须是有两套相同的图片连在一起才能实现滚动,即让ul的内容由原来的ul的内容×2，此时li和图片的数量又原来的4个变成了8个\n\n       \n```\n oUl.innerHTML=oUl.innerHTML+oUl.innerHTML;\n```\n\n* 相应的，ul的宽度要容得下由原来ul的内容×2之后的ul，即让ul的宽度变成8个li或者图片的宽度\n \n     \n```\noUl.style.width=oLi[0].offsetWidth*oLi.length+'px';//一定不能忘记单位 'px'\n```\n\n\n* 如果向右滚动，即speed>0的时候，当ul的最左端向右离开div的左端时（此时oUl.offsetLeft>0），立刻让ul的左边距变成ul宽度的一半重新滚动，相当于使了一个障眼法，让用户在浏览器上看起来是连续滚动的效果\n  \n    \n```\nif (speed>0){\n    if (oUl.offsetLeft>0) {\n    oUl.style.left=-oUl.offsetWidth/2+'px';}    //注意负号\n    }\n```\n\n* 同理，如果向左滚动，speed<0,当ul的左边距的绝对值（即-oUl.offsetLeft）大于ul宽度的一半时，立刻让ul的左边距变成0重新滚动\n\n    \n```\nif (speed<0){\n    if (-oUl.offsetLeft>oUl.offsetWidth/2) {oUl.style.left=0;}\n    }\n```\n\n* 综上，该无缝滚动的函数为\n\n    \n```\nfunction roll(){\n    if (speed>0){\n        if (oUl.offsetLeft>0) {oUl.style.left=-oUl.offsetWidth/2+'px';}\n    }\n    if (speed<0){\n        if (-oUl.offsetLeft>oUl.offsetWidth/2) {oUl.style.left=0;}\n    }\n    oUl.style.left=oUl.offsetLeft+speed+'px';\n    }\n```\n\n        \n* 如果想让这个div自动滚动，鼠标移入停止，鼠标移出继续滚动，只需用定时器即可\n      \n```\nvar timer=setInterval(roll,30);\n    oDiv.onmouseover=function(){\n        clearInterval(timer)\n    }\n    oDiv.onmouseout=function(){\n        timer=setInterval(roll,30);\n    }\n```\n","source":"_posts/定时器-图片无缝滚动效果.md","raw":"---\ntitle: 定时器-图片无缝滚动效果\ndate: 2016-12-09 14:20:49\ntags: 学习心得\n---\n# 用定时器实现图片无缝滚动效果\n### 效果思路\n1.布局：div>ul>li*4>img\n* div必须为相对定位，隐藏溢出\n* ul必须为绝对定位\n* 图片的宽高可自己规定\n\n2.实现无缝滚动的原理：所有的图片都看起来不能出div，div要随时保持有图片\n* 必须是有两套相同的图片连在一起才能实现滚动,即让ul的内容由原来的ul的内容×2，此时li和图片的数量又原来的4个变成了8个\n\n       \n```\n oUl.innerHTML=oUl.innerHTML+oUl.innerHTML;\n```\n\n* 相应的，ul的宽度要容得下由原来ul的内容×2之后的ul，即让ul的宽度变成8个li或者图片的宽度\n \n     \n```\noUl.style.width=oLi[0].offsetWidth*oLi.length+'px';//一定不能忘记单位 'px'\n```\n\n\n* 如果向右滚动，即speed>0的时候，当ul的最左端向右离开div的左端时（此时oUl.offsetLeft>0），立刻让ul的左边距变成ul宽度的一半重新滚动，相当于使了一个障眼法，让用户在浏览器上看起来是连续滚动的效果\n  \n    \n```\nif (speed>0){\n    if (oUl.offsetLeft>0) {\n    oUl.style.left=-oUl.offsetWidth/2+'px';}    //注意负号\n    }\n```\n\n* 同理，如果向左滚动，speed<0,当ul的左边距的绝对值（即-oUl.offsetLeft）大于ul宽度的一半时，立刻让ul的左边距变成0重新滚动\n\n    \n```\nif (speed<0){\n    if (-oUl.offsetLeft>oUl.offsetWidth/2) {oUl.style.left=0;}\n    }\n```\n\n* 综上，该无缝滚动的函数为\n\n    \n```\nfunction roll(){\n    if (speed>0){\n        if (oUl.offsetLeft>0) {oUl.style.left=-oUl.offsetWidth/2+'px';}\n    }\n    if (speed<0){\n        if (-oUl.offsetLeft>oUl.offsetWidth/2) {oUl.style.left=0;}\n    }\n    oUl.style.left=oUl.offsetLeft+speed+'px';\n    }\n```\n\n        \n* 如果想让这个div自动滚动，鼠标移入停止，鼠标移出继续滚动，只需用定时器即可\n      \n```\nvar timer=setInterval(roll,30);\n    oDiv.onmouseover=function(){\n        clearInterval(timer)\n    }\n    oDiv.onmouseout=function(){\n        timer=setInterval(roll,30);\n    }\n```\n","slug":"定时器-图片无缝滚动效果","published":1,"updated":"2017-01-17T15:08:23.579Z","_id":"ciwvcshlw00009o51smu1qt6s","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"用定时器实现图片无缝滚动效果\"><a href=\"#用定时器实现图片无缝滚动效果\" class=\"headerlink\" title=\"用定时器实现图片无缝滚动效果\"></a>用定时器实现图片无缝滚动效果</h1><h3 id=\"效果思路\"><a href=\"#效果思路\" class=\"headerlink\" title=\"效果思路\"></a>效果思路</h3><p>1.布局：div&gt;ul&gt;li*4&gt;img</p>\n<ul>\n<li>div必须为相对定位，隐藏溢出</li>\n<li>ul必须为绝对定位</li>\n<li>图片的宽高可自己规定</li>\n</ul>\n<p>2.实现无缝滚动的原理：所有的图片都看起来不能出div，div要随时保持有图片</p>\n<ul>\n<li>必须是有两套相同的图片连在一起才能实现滚动,即让ul的内容由原来的ul的内容×2，此时li和图片的数量又原来的4个变成了8个</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">oUl.innerHTML=oUl.innerHTML+oUl.innerHTML;</div></pre></td></tr></table></figure>\n<ul>\n<li>相应的，ul的宽度要容得下由原来ul的内容×2之后的ul，即让ul的宽度变成8个li或者图片的宽度</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">oUl.style.width=oLi[0].offsetWidth*oLi.length+&apos;px&apos;;//一定不能忘记单位 &apos;px&apos;</div></pre></td></tr></table></figure>\n<ul>\n<li>如果向右滚动，即speed&gt;0的时候，当ul的最左端向右离开div的左端时（此时oUl.offsetLeft&gt;0），立刻让ul的左边距变成ul宽度的一半重新滚动，相当于使了一个障眼法，让用户在浏览器上看起来是连续滚动的效果</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (speed&gt;0)&#123;</div><div class=\"line\">    if (oUl.offsetLeft&gt;0) &#123;</div><div class=\"line\">    oUl.style.left=-oUl.offsetWidth/2+&apos;px&apos;;&#125;    //注意负号</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>同理，如果向左滚动，speed&lt;0,当ul的左边距的绝对值（即-oUl.offsetLeft）大于ul宽度的一半时，立刻让ul的左边距变成0重新滚动</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (speed&lt;0)&#123;</div><div class=\"line\">    if (-oUl.offsetLeft&gt;oUl.offsetWidth/2) &#123;oUl.style.left=0;&#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>综上，该无缝滚动的函数为</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">function roll()&#123;</div><div class=\"line\">    if (speed&gt;0)&#123;</div><div class=\"line\">        if (oUl.offsetLeft&gt;0) &#123;oUl.style.left=-oUl.offsetWidth/2+&apos;px&apos;;&#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (speed&lt;0)&#123;</div><div class=\"line\">        if (-oUl.offsetLeft&gt;oUl.offsetWidth/2) &#123;oUl.style.left=0;&#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    oUl.style.left=oUl.offsetLeft+speed+&apos;px&apos;;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>如果想让这个div自动滚动，鼠标移入停止，鼠标移出继续滚动，只需用定时器即可</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">var timer=setInterval(roll,30);</div><div class=\"line\">    oDiv.onmouseover=function()&#123;</div><div class=\"line\">        clearInterval(timer)</div><div class=\"line\">    &#125;</div><div class=\"line\">    oDiv.onmouseout=function()&#123;</div><div class=\"line\">        timer=setInterval(roll,30);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<h1 id=\"用定时器实现图片无缝滚动效果\"><a href=\"#用定时器实现图片无缝滚动效果\" class=\"headerlink\" title=\"用定时器实现图片无缝滚动效果\"></a>用定时器实现图片无缝滚动效果</h1><h3 id=\"效果思路\"><a href=\"#效果思路\" class=\"headerlink\" title=\"效果思路\"></a>效果思路</h3><p>1.布局：div&gt;ul&gt;li*4&gt;img</p>\n<ul>\n<li>div必须为相对定位，隐藏溢出</li>\n<li>ul必须为绝对定位</li>\n<li>图片的宽高可自己规定</li>\n</ul>\n<p>2.实现无缝滚动的原理：所有的图片都看起来不能出div，div要随时保持有图片</p>\n<ul>\n<li>必须是有两套相同的图片连在一起才能实现滚动,即让ul的内容由原来的ul的内容×2，此时li和图片的数量又原来的4个变成了8个</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">oUl.innerHTML=oUl.innerHTML+oUl.innerHTML;</div></pre></td></tr></table></figure>\n<ul>\n<li>相应的，ul的宽度要容得下由原来ul的内容×2之后的ul，即让ul的宽度变成8个li或者图片的宽度</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">oUl.style.width=oLi[0].offsetWidth*oLi.length+&apos;px&apos;;//一定不能忘记单位 &apos;px&apos;</div></pre></td></tr></table></figure>\n<ul>\n<li>如果向右滚动，即speed&gt;0的时候，当ul的最左端向右离开div的左端时（此时oUl.offsetLeft&gt;0），立刻让ul的左边距变成ul宽度的一半重新滚动，相当于使了一个障眼法，让用户在浏览器上看起来是连续滚动的效果</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (speed&gt;0)&#123;</div><div class=\"line\">    if (oUl.offsetLeft&gt;0) &#123;</div><div class=\"line\">    oUl.style.left=-oUl.offsetWidth/2+&apos;px&apos;;&#125;    //注意负号</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>同理，如果向左滚动，speed&lt;0,当ul的左边距的绝对值（即-oUl.offsetLeft）大于ul宽度的一半时，立刻让ul的左边距变成0重新滚动</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (speed&lt;0)&#123;</div><div class=\"line\">    if (-oUl.offsetLeft&gt;oUl.offsetWidth/2) &#123;oUl.style.left=0;&#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>综上，该无缝滚动的函数为</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">function roll()&#123;</div><div class=\"line\">    if (speed&gt;0)&#123;</div><div class=\"line\">        if (oUl.offsetLeft&gt;0) &#123;oUl.style.left=-oUl.offsetWidth/2+&apos;px&apos;;&#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (speed&lt;0)&#123;</div><div class=\"line\">        if (-oUl.offsetLeft&gt;oUl.offsetWidth/2) &#123;oUl.style.left=0;&#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    oUl.style.left=oUl.offsetLeft+speed+&apos;px&apos;;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>如果想让这个div自动滚动，鼠标移入停止，鼠标移出继续滚动，只需用定时器即可</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">var timer=setInterval(roll,30);</div><div class=\"line\">    oDiv.onmouseover=function()&#123;</div><div class=\"line\">        clearInterval(timer)</div><div class=\"line\">    &#125;</div><div class=\"line\">    oDiv.onmouseout=function()&#123;</div><div class=\"line\">        timer=setInterval(roll,30);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n"},{"title":"DOM操作-表格排序","date":"2016-12-08T06:20:49.000Z","_content":"# DOM操作-表格排序\n## 知识点：\n* 表格相关：表格主体tBodies、行rows、单元格cells及它们的快捷获取\n* innerHTML方法\n* 数组排序sort()方法及sort（）括号中的函数\n* DOM添加子节点的方法appendChild()\n\n## 思路：\n\n1.表格的样式：\n* 可用css来设置表格的border-collaspe属性，这个属性的默认值为separate,表示每个单元格之间有空隙，可以将这个属性的值设置为collaspe让空隙消失\n* 必须在页面布局的时候在**table标签中设置行间样式边框border**，最好同时设置一个宽高，让表格好看一点\n        \n    \n```\n<table width=\"500px\" border='1px solid black' > <table>\n```\n\n\n2.进行表格布局的时候最好thead、tbody、tfoot都要有，虽然thead和tfoot看起来可有可无，但是如果没有的话有时候会出错，**尤其是thead**\n\n3.在JS中，表格的tBodies(注意是复数，因为tbody可能不止一个)、行rows、单元格cells不用事先用docement声明，可以直接获取使用\n\n    \n```\n    var oTab=document.getElementsByTagName('table')[0];\n    var oCells=oTab.tBodies[0].rows[0].cells;//表示表格内容中第1行的单元格\n```\n\n     \n4.对表格第一列的内容排序：先定义一个空数组，然后把表格中所有的行都放进数组里\n，即数组的成员就是所有的行\n   \n    \n```\nvar arr=[];\n    for (var i = 0; i < oTab.tBodies[0].rows.length; i++) {\n        arr[i]=oTab.tBodies[0].rows[i];\n    }\n```\n\n\n再根据所有行的**第一个单元格的内容**对这个数组进行排序\n\n```\narr.sort(function (a1,a2) {  //参数a1和a2 取自该数组arr\n   //由于要对第一列进行排序，就要把第一列（cells[0]的内容(innerHTML)转换为数字\n        var n1=parseInt(a1.cells[0].innerHTML);\n        var n2=parseInt(a2.cells[0].innerHTML);\n        return n1-n2;\n        })\n```\n注意：sort()方法括号里的函数的参数就是**取自这个数组**\n\n5.把排好序的数组（按第一个单元格内容排序之后的所有的行rows）添加为tBodies[0]的子节点。\n\nappendChild的功能：\n* 若子节点是创建出的新元素，则将子节点添加到指定的父节点\n* **若子节点原本就是存在的，则把该子节点从原父级删除然后添加到指定父级**\n\n这里用的是第二种功能\n\n```\n//别忘了使用循环！！\nfor (var i = 0; i < arr.length; i++) {\n    oTab.tBodies[0].appendChild(arr[i]);\n    }\n```\n\n","source":"_posts/DOM操作-表格排序.md","raw":"---\ntitle: DOM操作-表格排序\ndate: 2016-12-08 14:20:49\ntags: 学习心得\n---\n# DOM操作-表格排序\n## 知识点：\n* 表格相关：表格主体tBodies、行rows、单元格cells及它们的快捷获取\n* innerHTML方法\n* 数组排序sort()方法及sort（）括号中的函数\n* DOM添加子节点的方法appendChild()\n\n## 思路：\n\n1.表格的样式：\n* 可用css来设置表格的border-collaspe属性，这个属性的默认值为separate,表示每个单元格之间有空隙，可以将这个属性的值设置为collaspe让空隙消失\n* 必须在页面布局的时候在**table标签中设置行间样式边框border**，最好同时设置一个宽高，让表格好看一点\n        \n    \n```\n<table width=\"500px\" border='1px solid black' > <table>\n```\n\n\n2.进行表格布局的时候最好thead、tbody、tfoot都要有，虽然thead和tfoot看起来可有可无，但是如果没有的话有时候会出错，**尤其是thead**\n\n3.在JS中，表格的tBodies(注意是复数，因为tbody可能不止一个)、行rows、单元格cells不用事先用docement声明，可以直接获取使用\n\n    \n```\n    var oTab=document.getElementsByTagName('table')[0];\n    var oCells=oTab.tBodies[0].rows[0].cells;//表示表格内容中第1行的单元格\n```\n\n     \n4.对表格第一列的内容排序：先定义一个空数组，然后把表格中所有的行都放进数组里\n，即数组的成员就是所有的行\n   \n    \n```\nvar arr=[];\n    for (var i = 0; i < oTab.tBodies[0].rows.length; i++) {\n        arr[i]=oTab.tBodies[0].rows[i];\n    }\n```\n\n\n再根据所有行的**第一个单元格的内容**对这个数组进行排序\n\n```\narr.sort(function (a1,a2) {  //参数a1和a2 取自该数组arr\n   //由于要对第一列进行排序，就要把第一列（cells[0]的内容(innerHTML)转换为数字\n        var n1=parseInt(a1.cells[0].innerHTML);\n        var n2=parseInt(a2.cells[0].innerHTML);\n        return n1-n2;\n        })\n```\n注意：sort()方法括号里的函数的参数就是**取自这个数组**\n\n5.把排好序的数组（按第一个单元格内容排序之后的所有的行rows）添加为tBodies[0]的子节点。\n\nappendChild的功能：\n* 若子节点是创建出的新元素，则将子节点添加到指定的父节点\n* **若子节点原本就是存在的，则把该子节点从原父级删除然后添加到指定父级**\n\n这里用的是第二种功能\n\n```\n//别忘了使用循环！！\nfor (var i = 0; i < arr.length; i++) {\n    oTab.tBodies[0].appendChild(arr[i]);\n    }\n```\n\n","slug":"DOM操作-表格排序","published":1,"updated":"2017-01-17T15:08:23.576Z","_id":"ciwvcshm700019o51safx46aw","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"DOM操作-表格排序\"><a href=\"#DOM操作-表格排序\" class=\"headerlink\" title=\"DOM操作-表格排序\"></a>DOM操作-表格排序</h1><h2 id=\"知识点：\"><a href=\"#知识点：\" class=\"headerlink\" title=\"知识点：\"></a>知识点：</h2><ul>\n<li>表格相关：表格主体tBodies、行rows、单元格cells及它们的快捷获取</li>\n<li>innerHTML方法</li>\n<li>数组排序sort()方法及sort（）括号中的函数</li>\n<li>DOM添加子节点的方法appendChild()</li>\n</ul>\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>1.表格的样式：</p>\n<ul>\n<li>可用css来设置表格的border-collaspe属性，这个属性的默认值为separate,表示每个单元格之间有空隙，可以将这个属性的值设置为collaspe让空隙消失</li>\n<li>必须在页面布局的时候在<strong>table标签中设置行间样式边框border</strong>，最好同时设置一个宽高，让表格好看一点</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;table width=&quot;500px&quot; border=&apos;1px solid black&apos; &gt; &lt;table&gt;</div></pre></td></tr></table></figure>\n<p>2.进行表格布局的时候最好thead、tbody、tfoot都要有，虽然thead和tfoot看起来可有可无，但是如果没有的话有时候会出错，<strong>尤其是thead</strong></p>\n<p>3.在JS中，表格的tBodies(注意是复数，因为tbody可能不止一个)、行rows、单元格cells不用事先用docement声明，可以直接获取使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var oTab=document.getElementsByTagName(&apos;table&apos;)[0];</div><div class=\"line\">var oCells=oTab.tBodies[0].rows[0].cells;//表示表格内容中第1行的单元格</div></pre></td></tr></table></figure>\n<p>4.对表格第一列的内容排序：先定义一个空数组，然后把表格中所有的行都放进数组里<br>，即数组的成员就是所有的行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var arr=[];</div><div class=\"line\">    for (var i = 0; i &lt; oTab.tBodies[0].rows.length; i++) &#123;</div><div class=\"line\">        arr[i]=oTab.tBodies[0].rows[i];</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>再根据所有行的<strong>第一个单元格的内容</strong>对这个数组进行排序</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">arr.sort(function (a1,a2) &#123;  //参数a1和a2 取自该数组arr</div><div class=\"line\">   //由于要对第一列进行排序，就要把第一列（cells[0]的内容(innerHTML)转换为数字</div><div class=\"line\">        var n1=parseInt(a1.cells[0].innerHTML);</div><div class=\"line\">        var n2=parseInt(a2.cells[0].innerHTML);</div><div class=\"line\">        return n1-n2;</div><div class=\"line\">        &#125;)</div></pre></td></tr></table></figure>\n<p>注意：sort()方法括号里的函数的参数就是<strong>取自这个数组</strong></p>\n<p>5.把排好序的数组（按第一个单元格内容排序之后的所有的行rows）添加为tBodies[0]的子节点。</p>\n<p>appendChild的功能：</p>\n<ul>\n<li>若子节点是创建出的新元素，则将子节点添加到指定的父节点</li>\n<li><strong>若子节点原本就是存在的，则把该子节点从原父级删除然后添加到指定父级</strong></li>\n</ul>\n<p>这里用的是第二种功能</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">//别忘了使用循环！！</div><div class=\"line\">for (var i = 0; i &lt; arr.length; i++) &#123;</div><div class=\"line\">    oTab.tBodies[0].appendChild(arr[i]);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<h1 id=\"DOM操作-表格排序\"><a href=\"#DOM操作-表格排序\" class=\"headerlink\" title=\"DOM操作-表格排序\"></a>DOM操作-表格排序</h1><h2 id=\"知识点：\"><a href=\"#知识点：\" class=\"headerlink\" title=\"知识点：\"></a>知识点：</h2><ul>\n<li>表格相关：表格主体tBodies、行rows、单元格cells及它们的快捷获取</li>\n<li>innerHTML方法</li>\n<li>数组排序sort()方法及sort（）括号中的函数</li>\n<li>DOM添加子节点的方法appendChild()</li>\n</ul>\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>1.表格的样式：</p>\n<ul>\n<li>可用css来设置表格的border-collaspe属性，这个属性的默认值为separate,表示每个单元格之间有空隙，可以将这个属性的值设置为collaspe让空隙消失</li>\n<li>必须在页面布局的时候在<strong>table标签中设置行间样式边框border</strong>，最好同时设置一个宽高，让表格好看一点</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;table width=&quot;500px&quot; border=&apos;1px solid black&apos; &gt; &lt;table&gt;</div></pre></td></tr></table></figure>\n<p>2.进行表格布局的时候最好thead、tbody、tfoot都要有，虽然thead和tfoot看起来可有可无，但是如果没有的话有时候会出错，<strong>尤其是thead</strong></p>\n<p>3.在JS中，表格的tBodies(注意是复数，因为tbody可能不止一个)、行rows、单元格cells不用事先用docement声明，可以直接获取使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var oTab=document.getElementsByTagName(&apos;table&apos;)[0];</div><div class=\"line\">var oCells=oTab.tBodies[0].rows[0].cells;//表示表格内容中第1行的单元格</div></pre></td></tr></table></figure>\n<p>4.对表格第一列的内容排序：先定义一个空数组，然后把表格中所有的行都放进数组里<br>，即数组的成员就是所有的行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var arr=[];</div><div class=\"line\">    for (var i = 0; i &lt; oTab.tBodies[0].rows.length; i++) &#123;</div><div class=\"line\">        arr[i]=oTab.tBodies[0].rows[i];</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>再根据所有行的<strong>第一个单元格的内容</strong>对这个数组进行排序</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">arr.sort(function (a1,a2) &#123;  //参数a1和a2 取自该数组arr</div><div class=\"line\">   //由于要对第一列进行排序，就要把第一列（cells[0]的内容(innerHTML)转换为数字</div><div class=\"line\">        var n1=parseInt(a1.cells[0].innerHTML);</div><div class=\"line\">        var n2=parseInt(a2.cells[0].innerHTML);</div><div class=\"line\">        return n1-n2;</div><div class=\"line\">        &#125;)</div></pre></td></tr></table></figure>\n<p>注意：sort()方法括号里的函数的参数就是<strong>取自这个数组</strong></p>\n<p>5.把排好序的数组（按第一个单元格内容排序之后的所有的行rows）添加为tBodies[0]的子节点。</p>\n<p>appendChild的功能：</p>\n<ul>\n<li>若子节点是创建出的新元素，则将子节点添加到指定的父节点</li>\n<li><strong>若子节点原本就是存在的，则把该子节点从原父级删除然后添加到指定父级</strong></li>\n</ul>\n<p>这里用的是第二种功能</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">//别忘了使用循环！！</div><div class=\"line\">for (var i = 0; i &lt; arr.length; i++) &#123;</div><div class=\"line\">    oTab.tBodies[0].appendChild(arr[i]);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n"},{"title":"DOM操作-表格的添加删除搜索","date":"2016-12-10T06:20:49.000Z","_content":"### 知识点\n* DOM操作，添加删除子节点\n* 搜索：精确搜索、忽略大小写搜索、模糊搜索、多关键字搜索\n* 表格相关\n### 思路\n* 点击‘添加’按钮，添加一个行，在第一列添加id（每次都+1），在第二列添加第一个文本框中输入的内容，在第三列添加第二个文本框中输入的内容，在第四列添加一个用于删除该行的a链接，步骤如下：\n1. 新建一个行元素<tr>，并且将这个新的<tr>添加为tBody的子节点\n2. 新建第1个列元素<td>,它的内容为id++（需要提前声明id为已有行数+1），并且将这个新的<td>添加为刚才新建的<tr>的子节点\n3. 新建第2个列元素<td>,它的内容为第一个文本框中输入的内容，并且将这个新的<td>添加为刚才新建的<tr>的子节点\n4. 新建第3个列元素<td>,它的内容为第二个文本框中输入的内容，并且将这个新的<td>添加为刚才新建的<tr>的子节点\n5. 新建第4个列元素<td>,它的内容一个用于删除该行的a链接，并且将这个新的<td>添加为刚才新建的<tr>的子节点\n\n```\noBtn1.onclick=function() {\n        var oTr=document.createElement('tr');\n        oTab.tBodies[0].appendChild(oTr);\n\n        var oTd=document.createElement('td');\n        oTd.innerHTML=id++;\n        oTr.appendChild(oTd);\n\n        var oTd=document.createElement('td');\n        oTd.innerHTML=oName.value;\n        oName.value='';\n        oTr.appendChild(oTd);\n\n\n        var oTd=document.createElement('td');\n        oTd.innerHTML=oAge.value;\n        oAge.value='';\n        oTr.appendChild(oTd);\n\n        var oTd=document.createElement('td');\n        oTd.innerHTML='<a href=\"#\">删除</a>'\n        oTr.appendChild(oTd);\n ｝\n```\n* 点击“删除”，将该行删除。由于“删除”列元素的子节点，而需要删除的元素是行，所以应该是从tBdoy中删除这个a链接的父级的父级\n\n```\nvar aA=oTr.getElementsByTagName('a');\nfor (var i = 0; i < aA.length; i++) {\n    aA[i].onclick=function() {\n        oTab.tBodies[0].removeChild(this.parentNode.parentNode);\n    }\n}\n```\n需要注意的是，这些代码应该处于“添加”事件的函数中\n* 点击“搜索”按钮，搜索表格的name一列中与文本框中内容一致的行，并先把所有行的颜色清空，然后将符合搜索条件的行的颜色变成黄色，根据搜索要求不同，分为以下几种：\n1. 精确搜索：需要表格内容与搜索文本框中的内容一模一样\n\n```\noBtn2.onclick=function() {\n    for (var i = 0; i < oTab.tBodies[0].rows.length; i++) {\n        //先把所有行的颜色都清空\n        oTab.tBodies[0].rows[i].style.background='';\n        var sTxt=oSearch.value;\n        var sTab=oTab.tBodies[0].rows[i].cells[1].innerHTML;\n        //如果搜索框中的内容和表格某一行的内容相同，则把这一行变黄\n        if (sTxt==sTab) {       \n            oTab.tBodies[0].rows[i].style.background='yellow';\n        }\n    }   \n  }\n```\n2. 忽略大小写搜索：忽略大小写后，进行搜索\n\n```\noBtn2.onclick=function() {\n    for (var i = 0; i < oTab.tBodies[0].rows.length; i++) {\n     \n        oTab.tBodies[0].rows[i].style.background='';\n        \n        //把搜索框中的内容和表格内容都变成小写（或者大写也可以）\n        var sTxt=oSearch.value.toLowerCase();\n        var sTab=oTab.tBodies[0].rows[i].cells[1].innerHTML.toLowerCase();\n    \n        if (sTxt==sTab) {       \n            oTab.tBodies[0].rows[i].style.background='yellow';\n        }\n    }   \n  }\n```\n3. 模糊搜索：要求表格内容包含搜索内容。需要用到search方法。\n\n   语法为：要搜查的对象.search(搜查内容)       \n   若没有在要搜查的对象中找到搜查内容，则返回-1\n\n```\noBtn2.onclick=function() {\n    for (var i = 0; i < oTab.tBodies[0].rows.length; i++) {\n     \n        oTab.tBodies[0].rows[i].style.background='';\n        \n        //把搜索框中的内容和表格内容都变成小写（或者大写也可以）\n        var sTxt=oSearch.value.toLowerCase();\n        var sTab=oTab.tBodies[0].rows[i].cells[1].innerHTML.toLowerCase();\n        //如果search方法返回的不是-1，说明搜索到了\n        if (sTab.search(sTxt)!=-1) {        \n            oTab.tBodies[0].rows[i].style.background='yellow';\n        }\n    }   \n  }\n```\n4. 多关键字搜索：包含多个关键词的搜索，配合模糊搜索。需要用到split方法，通过指定的字符串或者符号（如空格）把一个字符串拆分成若干个子字符串然后将结果作为字符串数组返回。\n    \n    语法为：var arr=要被分解的字符串对象.split(指定的字符串)\n\n```\noBtn2.onclick=function() {\n    for (var i = 0; i < oTab.tBodies[0].rows.length; i++) {\n        oTab.tBodies[0].rows[i].style.background='';\n        var sTxt=oSearch.value.toLowerCase();\n        var sTab=oTab.tBodies[0].rows[i].cells[1].innerHTML.toLowerCase();\n        ////多关键字搜索，先把搜索框中的内容通过空格分解，然后加入数组\n        var arr=sTxt.split(' ');  \n        //对于数组中所有的子字符串，如果某行满足模糊搜索，则那一行就变黄\n        for (var  j= 0; j < arr.length; j++) {\n            if (sTab.search(arr[j]!=-1)) {\n                oTab.tBodies[0].rows[i].style.background='yellow';              \n            }\n        }\n    }\n}\n```\n\n\n\n","source":"_posts/DOM操作-表格的添加删除搜索.md","raw":"---\ntitle: DOM操作-表格的添加删除搜索\ndate: 2016-12-10 14:20:49\ntags: 学习心得\n---\n### 知识点\n* DOM操作，添加删除子节点\n* 搜索：精确搜索、忽略大小写搜索、模糊搜索、多关键字搜索\n* 表格相关\n### 思路\n* 点击‘添加’按钮，添加一个行，在第一列添加id（每次都+1），在第二列添加第一个文本框中输入的内容，在第三列添加第二个文本框中输入的内容，在第四列添加一个用于删除该行的a链接，步骤如下：\n1. 新建一个行元素<tr>，并且将这个新的<tr>添加为tBody的子节点\n2. 新建第1个列元素<td>,它的内容为id++（需要提前声明id为已有行数+1），并且将这个新的<td>添加为刚才新建的<tr>的子节点\n3. 新建第2个列元素<td>,它的内容为第一个文本框中输入的内容，并且将这个新的<td>添加为刚才新建的<tr>的子节点\n4. 新建第3个列元素<td>,它的内容为第二个文本框中输入的内容，并且将这个新的<td>添加为刚才新建的<tr>的子节点\n5. 新建第4个列元素<td>,它的内容一个用于删除该行的a链接，并且将这个新的<td>添加为刚才新建的<tr>的子节点\n\n```\noBtn1.onclick=function() {\n        var oTr=document.createElement('tr');\n        oTab.tBodies[0].appendChild(oTr);\n\n        var oTd=document.createElement('td');\n        oTd.innerHTML=id++;\n        oTr.appendChild(oTd);\n\n        var oTd=document.createElement('td');\n        oTd.innerHTML=oName.value;\n        oName.value='';\n        oTr.appendChild(oTd);\n\n\n        var oTd=document.createElement('td');\n        oTd.innerHTML=oAge.value;\n        oAge.value='';\n        oTr.appendChild(oTd);\n\n        var oTd=document.createElement('td');\n        oTd.innerHTML='<a href=\"#\">删除</a>'\n        oTr.appendChild(oTd);\n ｝\n```\n* 点击“删除”，将该行删除。由于“删除”列元素的子节点，而需要删除的元素是行，所以应该是从tBdoy中删除这个a链接的父级的父级\n\n```\nvar aA=oTr.getElementsByTagName('a');\nfor (var i = 0; i < aA.length; i++) {\n    aA[i].onclick=function() {\n        oTab.tBodies[0].removeChild(this.parentNode.parentNode);\n    }\n}\n```\n需要注意的是，这些代码应该处于“添加”事件的函数中\n* 点击“搜索”按钮，搜索表格的name一列中与文本框中内容一致的行，并先把所有行的颜色清空，然后将符合搜索条件的行的颜色变成黄色，根据搜索要求不同，分为以下几种：\n1. 精确搜索：需要表格内容与搜索文本框中的内容一模一样\n\n```\noBtn2.onclick=function() {\n    for (var i = 0; i < oTab.tBodies[0].rows.length; i++) {\n        //先把所有行的颜色都清空\n        oTab.tBodies[0].rows[i].style.background='';\n        var sTxt=oSearch.value;\n        var sTab=oTab.tBodies[0].rows[i].cells[1].innerHTML;\n        //如果搜索框中的内容和表格某一行的内容相同，则把这一行变黄\n        if (sTxt==sTab) {       \n            oTab.tBodies[0].rows[i].style.background='yellow';\n        }\n    }   \n  }\n```\n2. 忽略大小写搜索：忽略大小写后，进行搜索\n\n```\noBtn2.onclick=function() {\n    for (var i = 0; i < oTab.tBodies[0].rows.length; i++) {\n     \n        oTab.tBodies[0].rows[i].style.background='';\n        \n        //把搜索框中的内容和表格内容都变成小写（或者大写也可以）\n        var sTxt=oSearch.value.toLowerCase();\n        var sTab=oTab.tBodies[0].rows[i].cells[1].innerHTML.toLowerCase();\n    \n        if (sTxt==sTab) {       \n            oTab.tBodies[0].rows[i].style.background='yellow';\n        }\n    }   \n  }\n```\n3. 模糊搜索：要求表格内容包含搜索内容。需要用到search方法。\n\n   语法为：要搜查的对象.search(搜查内容)       \n   若没有在要搜查的对象中找到搜查内容，则返回-1\n\n```\noBtn2.onclick=function() {\n    for (var i = 0; i < oTab.tBodies[0].rows.length; i++) {\n     \n        oTab.tBodies[0].rows[i].style.background='';\n        \n        //把搜索框中的内容和表格内容都变成小写（或者大写也可以）\n        var sTxt=oSearch.value.toLowerCase();\n        var sTab=oTab.tBodies[0].rows[i].cells[1].innerHTML.toLowerCase();\n        //如果search方法返回的不是-1，说明搜索到了\n        if (sTab.search(sTxt)!=-1) {        \n            oTab.tBodies[0].rows[i].style.background='yellow';\n        }\n    }   \n  }\n```\n4. 多关键字搜索：包含多个关键词的搜索，配合模糊搜索。需要用到split方法，通过指定的字符串或者符号（如空格）把一个字符串拆分成若干个子字符串然后将结果作为字符串数组返回。\n    \n    语法为：var arr=要被分解的字符串对象.split(指定的字符串)\n\n```\noBtn2.onclick=function() {\n    for (var i = 0; i < oTab.tBodies[0].rows.length; i++) {\n        oTab.tBodies[0].rows[i].style.background='';\n        var sTxt=oSearch.value.toLowerCase();\n        var sTab=oTab.tBodies[0].rows[i].cells[1].innerHTML.toLowerCase();\n        ////多关键字搜索，先把搜索框中的内容通过空格分解，然后加入数组\n        var arr=sTxt.split(' ');  \n        //对于数组中所有的子字符串，如果某行满足模糊搜索，则那一行就变黄\n        for (var  j= 0; j < arr.length; j++) {\n            if (sTab.search(arr[j]!=-1)) {\n                oTab.tBodies[0].rows[i].style.background='yellow';              \n            }\n        }\n    }\n}\n```\n\n\n\n","slug":"DOM操作-表格的添加删除搜索","published":1,"updated":"2017-01-17T15:08:23.577Z","_id":"ciwvcshme00039o51jwt564rr","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h3><ul>\n<li>DOM操作，添加删除子节点</li>\n<li>搜索：精确搜索、忽略大小写搜索、模糊搜索、多关键字搜索</li>\n<li>表格相关<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3></li>\n<li>点击‘添加’按钮，添加一个行，在第一列添加id（每次都+1），在第二列添加第一个文本框中输入的内容，在第三列添加第二个文本框中输入的内容，在第四列添加一个用于删除该行的a链接，步骤如下：</li>\n</ul>\n<ol>\n<li>新建一个行元素<tr>，并且将这个新的</tr><tr>添加为tBody的子节点</tr></li>\n<li>新建第1个列元素<td>,它的内容为id++（需要提前声明id为已有行数+1），并且将这个新的</td><td>添加为刚才新建的</td><tr>的子节点</tr></li>\n<li>新建第2个列元素<td>,它的内容为第一个文本框中输入的内容，并且将这个新的</td><td>添加为刚才新建的</td><tr>的子节点</tr></li>\n<li>新建第3个列元素<td>,它的内容为第二个文本框中输入的内容，并且将这个新的</td><td>添加为刚才新建的</td><tr>的子节点</tr></li>\n<li>新建第4个列元素<td>,它的内容一个用于删除该行的a链接，并且将这个新的</td><td>添加为刚才新建的</td><tr>的子节点</tr></li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">oBtn1.onclick=function() &#123;</div><div class=\"line\">        var oTr=document.createElement(&apos;tr&apos;);</div><div class=\"line\">        oTab.tBodies[0].appendChild(oTr);</div><div class=\"line\"></div><div class=\"line\">        var oTd=document.createElement(&apos;td&apos;);</div><div class=\"line\">        oTd.innerHTML=id++;</div><div class=\"line\">        oTr.appendChild(oTd);</div><div class=\"line\"></div><div class=\"line\">        var oTd=document.createElement(&apos;td&apos;);</div><div class=\"line\">        oTd.innerHTML=oName.value;</div><div class=\"line\">        oName.value=&apos;&apos;;</div><div class=\"line\">        oTr.appendChild(oTd);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">        var oTd=document.createElement(&apos;td&apos;);</div><div class=\"line\">        oTd.innerHTML=oAge.value;</div><div class=\"line\">        oAge.value=&apos;&apos;;</div><div class=\"line\">        oTr.appendChild(oTd);</div><div class=\"line\"></div><div class=\"line\">        var oTd=document.createElement(&apos;td&apos;);</div><div class=\"line\">        oTd.innerHTML=&apos;&lt;a href=&quot;#&quot;&gt;删除&lt;/a&gt;&apos;</div><div class=\"line\">        oTr.appendChild(oTd);</div><div class=\"line\"> ｝</div></pre></td></tr></table></figure>\n<ul>\n<li>点击“删除”，将该行删除。由于“删除”列元素的子节点，而需要删除的元素是行，所以应该是从tBdoy中删除这个a链接的父级的父级</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var aA=oTr.getElementsByTagName(&apos;a&apos;);</div><div class=\"line\">for (var i = 0; i &lt; aA.length; i++) &#123;</div><div class=\"line\">    aA[i].onclick=function() &#123;</div><div class=\"line\">        oTab.tBodies[0].removeChild(this.parentNode.parentNode);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>需要注意的是，这些代码应该处于“添加”事件的函数中</p>\n<ul>\n<li>点击“搜索”按钮，搜索表格的name一列中与文本框中内容一致的行，并先把所有行的颜色清空，然后将符合搜索条件的行的颜色变成黄色，根据搜索要求不同，分为以下几种：</li>\n</ul>\n<ol>\n<li>精确搜索：需要表格内容与搜索文本框中的内容一模一样</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">oBtn2.onclick=function() &#123;</div><div class=\"line\">    for (var i = 0; i &lt; oTab.tBodies[0].rows.length; i++) &#123;</div><div class=\"line\">        //先把所有行的颜色都清空</div><div class=\"line\">        oTab.tBodies[0].rows[i].style.background=&apos;&apos;;</div><div class=\"line\">        var sTxt=oSearch.value;</div><div class=\"line\">        var sTab=oTab.tBodies[0].rows[i].cells[1].innerHTML;</div><div class=\"line\">        //如果搜索框中的内容和表格某一行的内容相同，则把这一行变黄</div><div class=\"line\">        if (sTxt==sTab) &#123;       </div><div class=\"line\">            oTab.tBodies[0].rows[i].style.background=&apos;yellow&apos;;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;   </div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>忽略大小写搜索：忽略大小写后，进行搜索</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">oBtn2.onclick=function() &#123;</div><div class=\"line\">    for (var i = 0; i &lt; oTab.tBodies[0].rows.length; i++) &#123;</div><div class=\"line\">     </div><div class=\"line\">        oTab.tBodies[0].rows[i].style.background=&apos;&apos;;</div><div class=\"line\">        </div><div class=\"line\">        //把搜索框中的内容和表格内容都变成小写（或者大写也可以）</div><div class=\"line\">        var sTxt=oSearch.value.toLowerCase();</div><div class=\"line\">        var sTab=oTab.tBodies[0].rows[i].cells[1].innerHTML.toLowerCase();</div><div class=\"line\">    </div><div class=\"line\">        if (sTxt==sTab) &#123;       </div><div class=\"line\">            oTab.tBodies[0].rows[i].style.background=&apos;yellow&apos;;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;   </div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<ol>\n<li><p>模糊搜索：要求表格内容包含搜索内容。需要用到search方法。</p>\n<p>语法为：要搜查的对象.search(搜查内容)<br>若没有在要搜查的对象中找到搜查内容，则返回-1</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">oBtn2.onclick=function() &#123;</div><div class=\"line\">    for (var i = 0; i &lt; oTab.tBodies[0].rows.length; i++) &#123;</div><div class=\"line\">     </div><div class=\"line\">        oTab.tBodies[0].rows[i].style.background=&apos;&apos;;</div><div class=\"line\">        </div><div class=\"line\">        //把搜索框中的内容和表格内容都变成小写（或者大写也可以）</div><div class=\"line\">        var sTxt=oSearch.value.toLowerCase();</div><div class=\"line\">        var sTab=oTab.tBodies[0].rows[i].cells[1].innerHTML.toLowerCase();</div><div class=\"line\">        //如果search方法返回的不是-1，说明搜索到了</div><div class=\"line\">        if (sTab.search(sTxt)!=-1) &#123;        </div><div class=\"line\">            oTab.tBodies[0].rows[i].style.background=&apos;yellow&apos;;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;   </div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<ol>\n<li><p>多关键字搜索：包含多个关键词的搜索，配合模糊搜索。需要用到split方法，通过指定的字符串或者符号（如空格）把一个字符串拆分成若干个子字符串然后将结果作为字符串数组返回。</p>\n<p> 语法为：var arr=要被分解的字符串对象.split(指定的字符串)</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">oBtn2.onclick=function() &#123;</div><div class=\"line\">    for (var i = 0; i &lt; oTab.tBodies[0].rows.length; i++) &#123;</div><div class=\"line\">        oTab.tBodies[0].rows[i].style.background=&apos;&apos;;</div><div class=\"line\">        var sTxt=oSearch.value.toLowerCase();</div><div class=\"line\">        var sTab=oTab.tBodies[0].rows[i].cells[1].innerHTML.toLowerCase();</div><div class=\"line\">        ////多关键字搜索，先把搜索框中的内容通过空格分解，然后加入数组</div><div class=\"line\">        var arr=sTxt.split(&apos; &apos;);  </div><div class=\"line\">        //对于数组中所有的子字符串，如果某行满足模糊搜索，则那一行就变黄</div><div class=\"line\">        for (var  j= 0; j &lt; arr.length; j++) &#123;</div><div class=\"line\">            if (sTab.search(arr[j]!=-1)) &#123;</div><div class=\"line\">                oTab.tBodies[0].rows[i].style.background=&apos;yellow&apos;;              </div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<h3 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h3><ul>\n<li>DOM操作，添加删除子节点</li>\n<li>搜索：精确搜索、忽略大小写搜索、模糊搜索、多关键字搜索</li>\n<li>表格相关<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3></li>\n<li>点击‘添加’按钮，添加一个行，在第一列添加id（每次都+1），在第二列添加第一个文本框中输入的内容，在第三列添加第二个文本框中输入的内容，在第四列添加一个用于删除该行的a链接，步骤如下：</li>\n</ul>\n<ol>\n<li>新建一个行元素<tr>，并且将这个新的<tr>添加为tBody的子节点</li>\n<li>新建第1个列元素<td>,它的内容为id++（需要提前声明id为已有行数+1），并且将这个新的<td>添加为刚才新建的<tr>的子节点</li>\n<li>新建第2个列元素<td>,它的内容为第一个文本框中输入的内容，并且将这个新的<td>添加为刚才新建的<tr>的子节点</li>\n<li>新建第3个列元素<td>,它的内容为第二个文本框中输入的内容，并且将这个新的<td>添加为刚才新建的<tr>的子节点</li>\n<li>新建第4个列元素<td>,它的内容一个用于删除该行的a链接，并且将这个新的<td>添加为刚才新建的<tr>的子节点</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">oBtn1.onclick=function() &#123;</div><div class=\"line\">        var oTr=document.createElement(&apos;tr&apos;);</div><div class=\"line\">        oTab.tBodies[0].appendChild(oTr);</div><div class=\"line\"></div><div class=\"line\">        var oTd=document.createElement(&apos;td&apos;);</div><div class=\"line\">        oTd.innerHTML=id++;</div><div class=\"line\">        oTr.appendChild(oTd);</div><div class=\"line\"></div><div class=\"line\">        var oTd=document.createElement(&apos;td&apos;);</div><div class=\"line\">        oTd.innerHTML=oName.value;</div><div class=\"line\">        oName.value=&apos;&apos;;</div><div class=\"line\">        oTr.appendChild(oTd);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">        var oTd=document.createElement(&apos;td&apos;);</div><div class=\"line\">        oTd.innerHTML=oAge.value;</div><div class=\"line\">        oAge.value=&apos;&apos;;</div><div class=\"line\">        oTr.appendChild(oTd);</div><div class=\"line\"></div><div class=\"line\">        var oTd=document.createElement(&apos;td&apos;);</div><div class=\"line\">        oTd.innerHTML=&apos;&lt;a href=&quot;#&quot;&gt;删除&lt;/a&gt;&apos;</div><div class=\"line\">        oTr.appendChild(oTd);</div><div class=\"line\"> ｝</div></pre></td></tr></table></figure>\n<ul>\n<li>点击“删除”，将该行删除。由于“删除”列元素的子节点，而需要删除的元素是行，所以应该是从tBdoy中删除这个a链接的父级的父级</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var aA=oTr.getElementsByTagName(&apos;a&apos;);</div><div class=\"line\">for (var i = 0; i &lt; aA.length; i++) &#123;</div><div class=\"line\">    aA[i].onclick=function() &#123;</div><div class=\"line\">        oTab.tBodies[0].removeChild(this.parentNode.parentNode);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>需要注意的是，这些代码应该处于“添加”事件的函数中</p>\n<ul>\n<li>点击“搜索”按钮，搜索表格的name一列中与文本框中内容一致的行，并先把所有行的颜色清空，然后将符合搜索条件的行的颜色变成黄色，根据搜索要求不同，分为以下几种：</li>\n</ul>\n<ol>\n<li>精确搜索：需要表格内容与搜索文本框中的内容一模一样</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">oBtn2.onclick=function() &#123;</div><div class=\"line\">    for (var i = 0; i &lt; oTab.tBodies[0].rows.length; i++) &#123;</div><div class=\"line\">        //先把所有行的颜色都清空</div><div class=\"line\">        oTab.tBodies[0].rows[i].style.background=&apos;&apos;;</div><div class=\"line\">        var sTxt=oSearch.value;</div><div class=\"line\">        var sTab=oTab.tBodies[0].rows[i].cells[1].innerHTML;</div><div class=\"line\">        //如果搜索框中的内容和表格某一行的内容相同，则把这一行变黄</div><div class=\"line\">        if (sTxt==sTab) &#123;       </div><div class=\"line\">            oTab.tBodies[0].rows[i].style.background=&apos;yellow&apos;;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;   </div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>忽略大小写搜索：忽略大小写后，进行搜索</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">oBtn2.onclick=function() &#123;</div><div class=\"line\">    for (var i = 0; i &lt; oTab.tBodies[0].rows.length; i++) &#123;</div><div class=\"line\">     </div><div class=\"line\">        oTab.tBodies[0].rows[i].style.background=&apos;&apos;;</div><div class=\"line\">        </div><div class=\"line\">        //把搜索框中的内容和表格内容都变成小写（或者大写也可以）</div><div class=\"line\">        var sTxt=oSearch.value.toLowerCase();</div><div class=\"line\">        var sTab=oTab.tBodies[0].rows[i].cells[1].innerHTML.toLowerCase();</div><div class=\"line\">    </div><div class=\"line\">        if (sTxt==sTab) &#123;       </div><div class=\"line\">            oTab.tBodies[0].rows[i].style.background=&apos;yellow&apos;;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;   </div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<ol>\n<li><p>模糊搜索：要求表格内容包含搜索内容。需要用到search方法。</p>\n<p>语法为：要搜查的对象.search(搜查内容)<br>若没有在要搜查的对象中找到搜查内容，则返回-1</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">oBtn2.onclick=function() &#123;</div><div class=\"line\">    for (var i = 0; i &lt; oTab.tBodies[0].rows.length; i++) &#123;</div><div class=\"line\">     </div><div class=\"line\">        oTab.tBodies[0].rows[i].style.background=&apos;&apos;;</div><div class=\"line\">        </div><div class=\"line\">        //把搜索框中的内容和表格内容都变成小写（或者大写也可以）</div><div class=\"line\">        var sTxt=oSearch.value.toLowerCase();</div><div class=\"line\">        var sTab=oTab.tBodies[0].rows[i].cells[1].innerHTML.toLowerCase();</div><div class=\"line\">        //如果search方法返回的不是-1，说明搜索到了</div><div class=\"line\">        if (sTab.search(sTxt)!=-1) &#123;        </div><div class=\"line\">            oTab.tBodies[0].rows[i].style.background=&apos;yellow&apos;;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;   </div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<ol>\n<li><p>多关键字搜索：包含多个关键词的搜索，配合模糊搜索。需要用到split方法，通过指定的字符串或者符号（如空格）把一个字符串拆分成若干个子字符串然后将结果作为字符串数组返回。</p>\n<p> 语法为：var arr=要被分解的字符串对象.split(指定的字符串)</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">oBtn2.onclick=function() &#123;</div><div class=\"line\">    for (var i = 0; i &lt; oTab.tBodies[0].rows.length; i++) &#123;</div><div class=\"line\">        oTab.tBodies[0].rows[i].style.background=&apos;&apos;;</div><div class=\"line\">        var sTxt=oSearch.value.toLowerCase();</div><div class=\"line\">        var sTab=oTab.tBodies[0].rows[i].cells[1].innerHTML.toLowerCase();</div><div class=\"line\">        ////多关键字搜索，先把搜索框中的内容通过空格分解，然后加入数组</div><div class=\"line\">        var arr=sTxt.split(&apos; &apos;);  </div><div class=\"line\">        //对于数组中所有的子字符串，如果某行满足模糊搜索，则那一行就变黄</div><div class=\"line\">        for (var  j= 0; j &lt; arr.length; j++) &#123;</div><div class=\"line\">            if (sTab.search(arr[j]!=-1)) &#123;</div><div class=\"line\">                oTab.tBodies[0].rows[i].style.background=&apos;yellow&apos;;              </div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"三种三栏式自适应宽度（两边固定，中间自适应）布局","date":"2016-12-19T00:37:08.000Z","_content":"\n最近在刷百度前端学院的题，刷到第三题(http://ife.baidu.com/task/detail?taskId=3) ， 觉得 **三栏式宽度自适应布局**很实用，有以下三种方法可以实现且 **无兼容性问题**：\n* 绝对定位法\n* 自身浮动法\n* margin负值法（即双飞翼布局）\n\n另外，如果想实现父元素的高度始终等于最高的那一栏的子元素的高度，可以使用让父元素*的min-height*等于左右两栏中最高一栏的height\n\n下面是详细说明：\n#### 1. 绝对定位法：\n左右两栏采用绝对定位，分别固定于页面的左右两侧，中间栏div的左右margin分别等于左右两栏的宽度加间隙。\n#### 2. 自身浮动法：\n**注意三个div的布局顺序**，中间栏放在左右栏之后。左栏左浮动，右栏右浮动，中间栏div的左右margin分别等于左右两栏的宽度加间隙。\n#### 3. margin负值法：\n**注意三个div的布局顺序**，与自身浮动法不一样，需要把中间栏div放最前面。首先，中间栏要使用双层标签。外层div宽度100%显示，并且浮动，内层div为真正的中间栏主体内容，左右margin分别等于左右两栏的宽度加间隙。左栏与右栏都是采用margin负值定位的，左栏左浮动，margin-left为-100%，由于前面的div宽度100%于浏览器，所以这里的-100%margin值正好使左栏div定位到了页面的左侧；右侧栏也是左浮动，其margin-left也是负值，大小为右栏本身的宽度。\n\n总结：\n* 绝对定位法：比较简单，容易理解，但是当浏览器宽度小到一定程度，会发生层重叠的情况，不过这种情况比较少见\n* 自身浮动法：同样很简单，代码量少，缺点是中间栏必须不能有clear:both属性\n* margin负值法：三栏相互关联，可谓真正意义上的自适应，有一定的抗性，但是比较复杂，出现了百分比宽度且负margin值多，出现了bug不好排查\n\n#### 参考：\n张鑫旭-我熟知的三种三栏网页宽度自适应布局方法http://www.zhangxinxu.com/wordpress/category/js/","source":"_posts/三种三栏式自适应宽度布局.md","raw":"---\ntitle: 三种三栏式自适应宽度（两边固定，中间自适应）布局\ndate: 2016-12-19 08:37:08\ntags: 学习心得\n---\n\n最近在刷百度前端学院的题，刷到第三题(http://ife.baidu.com/task/detail?taskId=3) ， 觉得 **三栏式宽度自适应布局**很实用，有以下三种方法可以实现且 **无兼容性问题**：\n* 绝对定位法\n* 自身浮动法\n* margin负值法（即双飞翼布局）\n\n另外，如果想实现父元素的高度始终等于最高的那一栏的子元素的高度，可以使用让父元素*的min-height*等于左右两栏中最高一栏的height\n\n下面是详细说明：\n#### 1. 绝对定位法：\n左右两栏采用绝对定位，分别固定于页面的左右两侧，中间栏div的左右margin分别等于左右两栏的宽度加间隙。\n#### 2. 自身浮动法：\n**注意三个div的布局顺序**，中间栏放在左右栏之后。左栏左浮动，右栏右浮动，中间栏div的左右margin分别等于左右两栏的宽度加间隙。\n#### 3. margin负值法：\n**注意三个div的布局顺序**，与自身浮动法不一样，需要把中间栏div放最前面。首先，中间栏要使用双层标签。外层div宽度100%显示，并且浮动，内层div为真正的中间栏主体内容，左右margin分别等于左右两栏的宽度加间隙。左栏与右栏都是采用margin负值定位的，左栏左浮动，margin-left为-100%，由于前面的div宽度100%于浏览器，所以这里的-100%margin值正好使左栏div定位到了页面的左侧；右侧栏也是左浮动，其margin-left也是负值，大小为右栏本身的宽度。\n\n总结：\n* 绝对定位法：比较简单，容易理解，但是当浏览器宽度小到一定程度，会发生层重叠的情况，不过这种情况比较少见\n* 自身浮动法：同样很简单，代码量少，缺点是中间栏必须不能有clear:both属性\n* margin负值法：三栏相互关联，可谓真正意义上的自适应，有一定的抗性，但是比较复杂，出现了百分比宽度且负margin值多，出现了bug不好排查\n\n#### 参考：\n张鑫旭-我熟知的三种三栏网页宽度自适应布局方法http://www.zhangxinxu.com/wordpress/category/js/","slug":"三种三栏式自适应宽度布局","published":1,"updated":"2017-01-17T15:08:23.578Z","_id":"ciwvcuh190000es51d17hzmml","comments":1,"layout":"post","photos":[],"link":"","content":"<p>最近在刷百度前端学院的题，刷到第三题(<a href=\"http://ife.baidu.com/task/detail?taskId=3\" target=\"_blank\" rel=\"external\">http://ife.baidu.com/task/detail?taskId=3</a>) ， 觉得 <strong>三栏式宽度自适应布局</strong>很实用，有以下三种方法可以实现且 <strong>无兼容性问题</strong>：</p>\n<ul>\n<li>绝对定位法</li>\n<li>自身浮动法</li>\n<li>margin负值法（即双飞翼布局）</li>\n</ul>\n<p>另外，如果想实现父元素的高度始终等于最高的那一栏的子元素的高度，可以使用让父元素<em>的min-height</em>等于左右两栏中最高一栏的height</p>\n<p>下面是详细说明：</p>\n<h4 id=\"1-绝对定位法：\"><a href=\"#1-绝对定位法：\" class=\"headerlink\" title=\"1. 绝对定位法：\"></a>1. 绝对定位法：</h4><p>左右两栏采用绝对定位，分别固定于页面的左右两侧，中间栏div的左右margin分别等于左右两栏的宽度加间隙。</p>\n<h4 id=\"2-自身浮动法：\"><a href=\"#2-自身浮动法：\" class=\"headerlink\" title=\"2. 自身浮动法：\"></a>2. 自身浮动法：</h4><p><strong>注意三个div的布局顺序</strong>，中间栏放在左右栏之后。左栏左浮动，右栏右浮动，中间栏div的左右margin分别等于左右两栏的宽度加间隙。</p>\n<h4 id=\"3-margin负值法：\"><a href=\"#3-margin负值法：\" class=\"headerlink\" title=\"3. margin负值法：\"></a>3. margin负值法：</h4><p><strong>注意三个div的布局顺序</strong>，与自身浮动法不一样，需要把中间栏div放最前面。首先，中间栏要使用双层标签。外层div宽度100%显示，并且浮动，内层div为真正的中间栏主体内容，左右margin分别等于左右两栏的宽度加间隙。左栏与右栏都是采用margin负值定位的，左栏左浮动，margin-left为-100%，由于前面的div宽度100%于浏览器，所以这里的-100%margin值正好使左栏div定位到了页面的左侧；右侧栏也是左浮动，其margin-left也是负值，大小为右栏本身的宽度。</p>\n<p>总结：</p>\n<ul>\n<li>绝对定位法：比较简单，容易理解，但是当浏览器宽度小到一定程度，会发生层重叠的情况，不过这种情况比较少见</li>\n<li>自身浮动法：同样很简单，代码量少，缺点是中间栏必须不能有clear:both属性</li>\n<li>margin负值法：三栏相互关联，可谓真正意义上的自适应，有一定的抗性，但是比较复杂，出现了百分比宽度且负margin值多，出现了bug不好排查</li>\n</ul>\n<h4 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h4><p>张鑫旭-我熟知的三种三栏网页宽度自适应布局方法<a href=\"http://www.zhangxinxu.com/wordpress/category/js/\" target=\"_blank\" rel=\"external\">http://www.zhangxinxu.com/wordpress/category/js/</a></p>\n","excerpt":"","more":"<p>最近在刷百度前端学院的题，刷到第三题(<a href=\"http://ife.baidu.com/task/detail?taskId=3\">http://ife.baidu.com/task/detail?taskId=3</a>) ， 觉得 <strong>三栏式宽度自适应布局</strong>很实用，有以下三种方法可以实现且 <strong>无兼容性问题</strong>：</p>\n<ul>\n<li>绝对定位法</li>\n<li>自身浮动法</li>\n<li>margin负值法（即双飞翼布局）</li>\n</ul>\n<p>另外，如果想实现父元素的高度始终等于最高的那一栏的子元素的高度，可以使用让父元素<em>的min-height</em>等于左右两栏中最高一栏的height</p>\n<p>下面是详细说明：</p>\n<h4 id=\"1-绝对定位法：\"><a href=\"#1-绝对定位法：\" class=\"headerlink\" title=\"1. 绝对定位法：\"></a>1. 绝对定位法：</h4><p>左右两栏采用绝对定位，分别固定于页面的左右两侧，中间栏div的左右margin分别等于左右两栏的宽度加间隙。</p>\n<h4 id=\"2-自身浮动法：\"><a href=\"#2-自身浮动法：\" class=\"headerlink\" title=\"2. 自身浮动法：\"></a>2. 自身浮动法：</h4><p><strong>注意三个div的布局顺序</strong>，中间栏放在左右栏之后。左栏左浮动，右栏右浮动，中间栏div的左右margin分别等于左右两栏的宽度加间隙。</p>\n<h4 id=\"3-margin负值法：\"><a href=\"#3-margin负值法：\" class=\"headerlink\" title=\"3. margin负值法：\"></a>3. margin负值法：</h4><p><strong>注意三个div的布局顺序</strong>，与自身浮动法不一样，需要把中间栏div放最前面。首先，中间栏要使用双层标签。外层div宽度100%显示，并且浮动，内层div为真正的中间栏主体内容，左右margin分别等于左右两栏的宽度加间隙。左栏与右栏都是采用margin负值定位的，左栏左浮动，margin-left为-100%，由于前面的div宽度100%于浏览器，所以这里的-100%margin值正好使左栏div定位到了页面的左侧；右侧栏也是左浮动，其margin-left也是负值，大小为右栏本身的宽度。</p>\n<p>总结：</p>\n<ul>\n<li>绝对定位法：比较简单，容易理解，但是当浏览器宽度小到一定程度，会发生层重叠的情况，不过这种情况比较少见</li>\n<li>自身浮动法：同样很简单，代码量少，缺点是中间栏必须不能有clear:both属性</li>\n<li>margin负值法：三栏相互关联，可谓真正意义上的自适应，有一定的抗性，但是比较复杂，出现了百分比宽度且负margin值多，出现了bug不好排查</li>\n</ul>\n<h4 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h4><p>张鑫旭-我熟知的三种三栏网页宽度自适应布局方法<a href=\"http://www.zhangxinxu.com/wordpress/category/js/\">http://www.zhangxinxu.com/wordpress/category/js/</a></p>\n"},{"title":"循环、迭代、遍历和递归","date":"2016-12-20T01:37:08.000Z","_content":"\nloop、iterate、traversal和recursion这几个词是计算机技术书中经常会出现的几个词汇。众所周知，这几个词分别翻译为：循环、迭代、遍历和递归。乍一看，这几个词好像都与重复（repeat）有关，但有的又好像不完全是重复的意思。那么这几个词到底各是什么含义，有什么区别和联系呢？下面就试着解释一下。\n\n* 循环（loop），指的是在满足条件的情况下，重复执行同一段代码。比如，while语句。\n* 迭代（iterate），指的是按照某种顺序逐个访问列表中的每一项。比如，for语句。\n* 遍历（traversal），指的是按照一定的规则访问树形结构中的每个节点，而且每个节点都只访问一次。\n* 递归（recursion），指的是一个函数不断调用自身的行为。比如，以编程方式输出著名的斐波纳契数列。\n\n有了以上定义，这几个概念之间的区别其实就比较清楚了。至于它们之间的联系，严格来讲，它们似乎都属于算法的范畴。换句话说，它们只不过是解决问题的不同手段和方式，而本质上则都是计算机编程中达成特定目标的途径。\n\n更深入的解释和举例：\n* 迭代是遍历的一种形式\n* 迭代是循环的一种，而迭代与普通循环的区别是：循环代码中参与运算的变量同时是保存结果的变量，当前保存的结果作为下一次循环计算的初始值。\n* 迭代是A执行B很多次，每次旨在更接近目标。或者说迭代是逐渐逼近，用输出作为输入，用新值覆盖旧值，直到满足条件后结束，不保存中间值，空间利用率高。例如你要给某个小孩子买玩具。你挑了一件觉得不行，又挑了一件又不行。如此这般，直到找到合适的玩具。\n* 递归是自己调用自己，每次旨在缩小问题规模。例如说你要给某个小孩子买玩具。你自己不太了解小孩子的需求，为了缩小范围，让你的儿子去给孙子挑选。儿子比你强点有限，但依然不太了解小孩子的需求。为了缩小范围，你又让你孙子去挑选。如此这般，直到找到合适的玩具。","source":"_posts/循环、迭代、遍历和递归.md","raw":"---\ntitle: 循环、迭代、遍历和递归\ndate: 2016-12-20 09:37:08\ntags: 学习心得\n---\n\nloop、iterate、traversal和recursion这几个词是计算机技术书中经常会出现的几个词汇。众所周知，这几个词分别翻译为：循环、迭代、遍历和递归。乍一看，这几个词好像都与重复（repeat）有关，但有的又好像不完全是重复的意思。那么这几个词到底各是什么含义，有什么区别和联系呢？下面就试着解释一下。\n\n* 循环（loop），指的是在满足条件的情况下，重复执行同一段代码。比如，while语句。\n* 迭代（iterate），指的是按照某种顺序逐个访问列表中的每一项。比如，for语句。\n* 遍历（traversal），指的是按照一定的规则访问树形结构中的每个节点，而且每个节点都只访问一次。\n* 递归（recursion），指的是一个函数不断调用自身的行为。比如，以编程方式输出著名的斐波纳契数列。\n\n有了以上定义，这几个概念之间的区别其实就比较清楚了。至于它们之间的联系，严格来讲，它们似乎都属于算法的范畴。换句话说，它们只不过是解决问题的不同手段和方式，而本质上则都是计算机编程中达成特定目标的途径。\n\n更深入的解释和举例：\n* 迭代是遍历的一种形式\n* 迭代是循环的一种，而迭代与普通循环的区别是：循环代码中参与运算的变量同时是保存结果的变量，当前保存的结果作为下一次循环计算的初始值。\n* 迭代是A执行B很多次，每次旨在更接近目标。或者说迭代是逐渐逼近，用输出作为输入，用新值覆盖旧值，直到满足条件后结束，不保存中间值，空间利用率高。例如你要给某个小孩子买玩具。你挑了一件觉得不行，又挑了一件又不行。如此这般，直到找到合适的玩具。\n* 递归是自己调用自己，每次旨在缩小问题规模。例如说你要给某个小孩子买玩具。你自己不太了解小孩子的需求，为了缩小范围，让你的儿子去给孙子挑选。儿子比你强点有限，但依然不太了解小孩子的需求。为了缩小范围，你又让你孙子去挑选。如此这般，直到找到合适的玩具。","slug":"循环、迭代、遍历和递归","published":1,"updated":"2017-01-17T15:08:23.580Z","_id":"ciwysvl5h00000s517y78kge1","comments":1,"layout":"post","photos":[],"link":"","content":"<p>loop、iterate、traversal和recursion这几个词是计算机技术书中经常会出现的几个词汇。众所周知，这几个词分别翻译为：循环、迭代、遍历和递归。乍一看，这几个词好像都与重复（repeat）有关，但有的又好像不完全是重复的意思。那么这几个词到底各是什么含义，有什么区别和联系呢？下面就试着解释一下。</p>\n<ul>\n<li>循环（loop），指的是在满足条件的情况下，重复执行同一段代码。比如，while语句。</li>\n<li>迭代（iterate），指的是按照某种顺序逐个访问列表中的每一项。比如，for语句。</li>\n<li>遍历（traversal），指的是按照一定的规则访问树形结构中的每个节点，而且每个节点都只访问一次。</li>\n<li>递归（recursion），指的是一个函数不断调用自身的行为。比如，以编程方式输出著名的斐波纳契数列。</li>\n</ul>\n<p>有了以上定义，这几个概念之间的区别其实就比较清楚了。至于它们之间的联系，严格来讲，它们似乎都属于算法的范畴。换句话说，它们只不过是解决问题的不同手段和方式，而本质上则都是计算机编程中达成特定目标的途径。</p>\n<p>更深入的解释和举例：</p>\n<ul>\n<li>迭代是遍历的一种形式</li>\n<li>迭代是循环的一种，而迭代与普通循环的区别是：循环代码中参与运算的变量同时是保存结果的变量，当前保存的结果作为下一次循环计算的初始值。</li>\n<li>迭代是A执行B很多次，每次旨在更接近目标。或者说迭代是逐渐逼近，用输出作为输入，用新值覆盖旧值，直到满足条件后结束，不保存中间值，空间利用率高。例如你要给某个小孩子买玩具。你挑了一件觉得不行，又挑了一件又不行。如此这般，直到找到合适的玩具。</li>\n<li>递归是自己调用自己，每次旨在缩小问题规模。例如说你要给某个小孩子买玩具。你自己不太了解小孩子的需求，为了缩小范围，让你的儿子去给孙子挑选。儿子比你强点有限，但依然不太了解小孩子的需求。为了缩小范围，你又让你孙子去挑选。如此这般，直到找到合适的玩具。</li>\n</ul>\n","excerpt":"","more":"<p>loop、iterate、traversal和recursion这几个词是计算机技术书中经常会出现的几个词汇。众所周知，这几个词分别翻译为：循环、迭代、遍历和递归。乍一看，这几个词好像都与重复（repeat）有关，但有的又好像不完全是重复的意思。那么这几个词到底各是什么含义，有什么区别和联系呢？下面就试着解释一下。</p>\n<ul>\n<li>循环（loop），指的是在满足条件的情况下，重复执行同一段代码。比如，while语句。</li>\n<li>迭代（iterate），指的是按照某种顺序逐个访问列表中的每一项。比如，for语句。</li>\n<li>遍历（traversal），指的是按照一定的规则访问树形结构中的每个节点，而且每个节点都只访问一次。</li>\n<li>递归（recursion），指的是一个函数不断调用自身的行为。比如，以编程方式输出著名的斐波纳契数列。</li>\n</ul>\n<p>有了以上定义，这几个概念之间的区别其实就比较清楚了。至于它们之间的联系，严格来讲，它们似乎都属于算法的范畴。换句话说，它们只不过是解决问题的不同手段和方式，而本质上则都是计算机编程中达成特定目标的途径。</p>\n<p>更深入的解释和举例：</p>\n<ul>\n<li>迭代是遍历的一种形式</li>\n<li>迭代是循环的一种，而迭代与普通循环的区别是：循环代码中参与运算的变量同时是保存结果的变量，当前保存的结果作为下一次循环计算的初始值。</li>\n<li>迭代是A执行B很多次，每次旨在更接近目标。或者说迭代是逐渐逼近，用输出作为输入，用新值覆盖旧值，直到满足条件后结束，不保存中间值，空间利用率高。例如你要给某个小孩子买玩具。你挑了一件觉得不行，又挑了一件又不行。如此这般，直到找到合适的玩具。</li>\n<li>递归是自己调用自己，每次旨在缩小问题规模。例如说你要给某个小孩子买玩具。你自己不太了解小孩子的需求，为了缩小范围，让你的儿子去给孙子挑选。儿子比你强点有限，但依然不太了解小孩子的需求。为了缩小范围，你又让你孙子去挑选。如此这般，直到找到合适的玩具。</li>\n</ul>\n"},{"title":"闭包小结","date":"2016-12-20T01:37:08.000Z","_content":"### 前言\n闭包是JS的一大特色，最近在学习《javascript高级程序设计》的函数部分时，遇到了闭包，在查阅各种资料后有了以下的心得\n#### 什么是闭包？\n闭包就是一个函数（不妨叫它fnChild），这个函数fnChild定义在它的父函数（fnParent）的内部，且能够读取fnParent的变量对象。\n#### 闭包的前提\n当函数fnParent的子函数fnChild被函数fnParent外的一个变量(通常是全局变量)引用的时候，就创建了一个我们通常所谓的“闭包”\n\n#### 闭包的作用\n1. **在函数外部访问这个函数的局部变量**\n\n在fnParent的外部，如果想直接访问fnParent的变量对象，是行不通的，这时候就需要用到闭包了，给fnParent的内部创建一个子函数fnChild，fnChild就是闭包，闭包将fnParent的内部和外部连接了起来。\n\n既然fnChild可以访问fnChild的局部变量，那么直接把fnChild作为fnParent的返回值，然后把fnChild赋值给一个全局变量，不就可以在fnParent外部通过这个全局变量来访问fnParent的局部变量了吗？！\n```\nfunction fnParent(){\n　var n=999;\n　return　function fnChild(){\n　　　　alert(n);\n　　}\n}\nvar a=fnParent();   //执行fnParent，并将返回值fnChild（即闭包）赋给全局变量a\na();    //执行a函数，访问 fnParent中的局部变量n\n```\n\n2. **让函数的局部变量一直保存在内存中不被销毁**\n\n当从fnParent中返回它的子函数fnChild时，fnChild就是闭包，如果把fnChild赋值给一个全局变量，fnChild就一直存在于内存中，而子函数fnChild的存在又依赖父函数fnParent,故父函数fnParent也始终存在于内存中，因此导致在fnParent执行完毕后，这个函数内的局部变量对象并不会被回收，直到闭包被销毁后，fnParent的变量对象才能被销毁。\n\n在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。\n```\n　　function f1(){\n　　　　var n=999;\n　　　　nAdd=function(){n+=1}\n　　　　function f2(){\n　　　　　　alert(n);\n　　　　}\n　　　　return f2;\n　　}\n　　var result=f1();\n　　result(); // 999\n　　nAdd();\n　　result(); // 1000\n```\n\n##### 总而言之，闭包就是一个定义在父函数中的函数，闭包除了是一个函数外，还保存着父函数的局部变量对象，使得在全局环境中调用闭包时还能访问父函数的变量，并且父函数的变量始终在内存中。\n\n#### 使用闭包的注意点\n\n* 闭包保存的是父函数的整个变量对象（即引用），而不是某个具体的变量。当某个变量有多个值时，最后的值会覆盖前面的值，所以闭包只能取得父函数中任何变量的最后一个值。当闭包处在循环语句块的时候尤其要注意这一点。\n\n    例如下面的代码，我们的设想是我们点击按钮的时候，点击第一个按钮提示 “我是第0个按钮”，点击第二个按钮提示 “我是第1个按钮”，以此类推。但是事实上，当我们运行的时候就会发现，无论点击哪个按钮，都会提示：“我是第3个按钮”。每次循环的时候闭包要取得i的值，但是这里的i并不是一个具体的变量，而是一个变量对象（即引用），当某个变量有多个值时，最后的值会覆盖前面的值，所以在每个函数内部 i 的值都是 3 。\n\n\n```\n<body>\n    <button>我是第0个按钮</button>\n    <button>我是第1个按钮</button>\n    <button>我是第2个按钮</button>\n    <script type=\"text/javascript\">\n    window.onload=function () {\n        var btns = document.getElementsByTagName(\"button\");\n        for(var i = 0; i < btns.length; i++){\n            btns[i].onclick = function() {\n                alert(\"我是第\" + i + \"个按钮\");\n            }\n        }\n    }\n    </script>\n</body>\n```\n解决方法是在这个闭包内创建一个匿名函数让闭包的行为符合预期。\n```\nfor(var i = 0; i < btns.length; i++){\n    btns[i].onclick = (function(num){\n        return function() { //在闭包内再设置一个匿名函数\n            alert(\"我是第\" + num + \"个按钮\");\n        }\n    })(i);\n}\n```\n\n* 闭包中的this对象：匿名函数的执行环境具有全局性，所以匿名函数的this通常指向window（不使用call(),apple(),bind()的情况下）。\n\n    在闭包中，匿名函数不会取得其父函数或者外部作用域的this对象，而是直接取它自己的this对象，因为每个函数在调用的时候都会自动取得两个特殊变量：this和arguments，闭包也不例外，既然闭包自己就有this(window)和arguments，那么何必去别的地方找呢？\n```\nvar name ='the Window';\nvar obj={\n  name:'zys',\n  getName:function () {\n     return function () {\n      return this.name;     //这个匿名函数的this其实是window\n    }\n  }\n}\nalert(obj.getName()())      //弹出the Window\n```\n\n\n    如果想要匿名函数取得其父函数的this对象，可以把其父函数的this保存给一个闭包能访问到的变量\n\n```\nvar name ='the Window';\nvar obj={\n  name:'zys',\n  getName:function () {\n     var that=this;     //把这个方法的this(即obj) 先保存给变量that\n     return function () {\n      return that.name;\n    }\n  }\n}\nalert(obj.getName()())      //弹出zys\n```\n\n\n* 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。\n* 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象使用，把闭包当作它的公用方法，把内部变量当作它的私有属性，这时一定要小心，不要随便改变父函数内部变量的值。\n\n### 参考：\n1. @亓官翊宸  简书-JavaScript 中的作用域链（scope chain）和闭包\nhttp://www.jianshu.com/p/ac926e0d6811\n2. @milter  简书-教你步步为营掌握JavaScript闭包\nhttp://www.jianshu.com/p/c63edc058504\n3. 阮一峰的网络日志- 学习Javascript闭包（Closure）\nhttp://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html\n\n","source":"_posts/闭包小结.md","raw":"---\ntitle: 闭包小结\ndate: 2016-12-20 09:37:08\ntags: 学习心得\n---\n### 前言\n闭包是JS的一大特色，最近在学习《javascript高级程序设计》的函数部分时，遇到了闭包，在查阅各种资料后有了以下的心得\n#### 什么是闭包？\n闭包就是一个函数（不妨叫它fnChild），这个函数fnChild定义在它的父函数（fnParent）的内部，且能够读取fnParent的变量对象。\n#### 闭包的前提\n当函数fnParent的子函数fnChild被函数fnParent外的一个变量(通常是全局变量)引用的时候，就创建了一个我们通常所谓的“闭包”\n\n#### 闭包的作用\n1. **在函数外部访问这个函数的局部变量**\n\n在fnParent的外部，如果想直接访问fnParent的变量对象，是行不通的，这时候就需要用到闭包了，给fnParent的内部创建一个子函数fnChild，fnChild就是闭包，闭包将fnParent的内部和外部连接了起来。\n\n既然fnChild可以访问fnChild的局部变量，那么直接把fnChild作为fnParent的返回值，然后把fnChild赋值给一个全局变量，不就可以在fnParent外部通过这个全局变量来访问fnParent的局部变量了吗？！\n```\nfunction fnParent(){\n　var n=999;\n　return　function fnChild(){\n　　　　alert(n);\n　　}\n}\nvar a=fnParent();   //执行fnParent，并将返回值fnChild（即闭包）赋给全局变量a\na();    //执行a函数，访问 fnParent中的局部变量n\n```\n\n2. **让函数的局部变量一直保存在内存中不被销毁**\n\n当从fnParent中返回它的子函数fnChild时，fnChild就是闭包，如果把fnChild赋值给一个全局变量，fnChild就一直存在于内存中，而子函数fnChild的存在又依赖父函数fnParent,故父函数fnParent也始终存在于内存中，因此导致在fnParent执行完毕后，这个函数内的局部变量对象并不会被回收，直到闭包被销毁后，fnParent的变量对象才能被销毁。\n\n在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。\n```\n　　function f1(){\n　　　　var n=999;\n　　　　nAdd=function(){n+=1}\n　　　　function f2(){\n　　　　　　alert(n);\n　　　　}\n　　　　return f2;\n　　}\n　　var result=f1();\n　　result(); // 999\n　　nAdd();\n　　result(); // 1000\n```\n\n##### 总而言之，闭包就是一个定义在父函数中的函数，闭包除了是一个函数外，还保存着父函数的局部变量对象，使得在全局环境中调用闭包时还能访问父函数的变量，并且父函数的变量始终在内存中。\n\n#### 使用闭包的注意点\n\n* 闭包保存的是父函数的整个变量对象（即引用），而不是某个具体的变量。当某个变量有多个值时，最后的值会覆盖前面的值，所以闭包只能取得父函数中任何变量的最后一个值。当闭包处在循环语句块的时候尤其要注意这一点。\n\n    例如下面的代码，我们的设想是我们点击按钮的时候，点击第一个按钮提示 “我是第0个按钮”，点击第二个按钮提示 “我是第1个按钮”，以此类推。但是事实上，当我们运行的时候就会发现，无论点击哪个按钮，都会提示：“我是第3个按钮”。每次循环的时候闭包要取得i的值，但是这里的i并不是一个具体的变量，而是一个变量对象（即引用），当某个变量有多个值时，最后的值会覆盖前面的值，所以在每个函数内部 i 的值都是 3 。\n\n\n```\n<body>\n    <button>我是第0个按钮</button>\n    <button>我是第1个按钮</button>\n    <button>我是第2个按钮</button>\n    <script type=\"text/javascript\">\n    window.onload=function () {\n        var btns = document.getElementsByTagName(\"button\");\n        for(var i = 0; i < btns.length; i++){\n            btns[i].onclick = function() {\n                alert(\"我是第\" + i + \"个按钮\");\n            }\n        }\n    }\n    </script>\n</body>\n```\n解决方法是在这个闭包内创建一个匿名函数让闭包的行为符合预期。\n```\nfor(var i = 0; i < btns.length; i++){\n    btns[i].onclick = (function(num){\n        return function() { //在闭包内再设置一个匿名函数\n            alert(\"我是第\" + num + \"个按钮\");\n        }\n    })(i);\n}\n```\n\n* 闭包中的this对象：匿名函数的执行环境具有全局性，所以匿名函数的this通常指向window（不使用call(),apple(),bind()的情况下）。\n\n    在闭包中，匿名函数不会取得其父函数或者外部作用域的this对象，而是直接取它自己的this对象，因为每个函数在调用的时候都会自动取得两个特殊变量：this和arguments，闭包也不例外，既然闭包自己就有this(window)和arguments，那么何必去别的地方找呢？\n```\nvar name ='the Window';\nvar obj={\n  name:'zys',\n  getName:function () {\n     return function () {\n      return this.name;     //这个匿名函数的this其实是window\n    }\n  }\n}\nalert(obj.getName()())      //弹出the Window\n```\n\n\n    如果想要匿名函数取得其父函数的this对象，可以把其父函数的this保存给一个闭包能访问到的变量\n\n```\nvar name ='the Window';\nvar obj={\n  name:'zys',\n  getName:function () {\n     var that=this;     //把这个方法的this(即obj) 先保存给变量that\n     return function () {\n      return that.name;\n    }\n  }\n}\nalert(obj.getName()())      //弹出zys\n```\n\n\n* 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。\n* 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象使用，把闭包当作它的公用方法，把内部变量当作它的私有属性，这时一定要小心，不要随便改变父函数内部变量的值。\n\n### 参考：\n1. @亓官翊宸  简书-JavaScript 中的作用域链（scope chain）和闭包\nhttp://www.jianshu.com/p/ac926e0d6811\n2. @milter  简书-教你步步为营掌握JavaScript闭包\nhttp://www.jianshu.com/p/c63edc058504\n3. 阮一峰的网络日志- 学习Javascript闭包（Closure）\nhttp://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html\n\n","slug":"闭包小结","published":1,"updated":"2017-01-17T15:08:23.580Z","_id":"cix1hurke0000oc51iijx95j1","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>闭包是JS的一大特色，最近在学习《javascript高级程序设计》的函数部分时，遇到了闭包，在查阅各种资料后有了以下的心得</p>\n<h4 id=\"什么是闭包？\"><a href=\"#什么是闭包？\" class=\"headerlink\" title=\"什么是闭包？\"></a>什么是闭包？</h4><p>闭包就是一个函数（不妨叫它fnChild），这个函数fnChild定义在它的父函数（fnParent）的内部，且能够读取fnParent的变量对象。</p>\n<h4 id=\"闭包的前提\"><a href=\"#闭包的前提\" class=\"headerlink\" title=\"闭包的前提\"></a>闭包的前提</h4><p>当函数fnParent的子函数fnChild被函数fnParent外的一个变量(通常是全局变量)引用的时候，就创建了一个我们通常所谓的“闭包”</p>\n<h4 id=\"闭包的作用\"><a href=\"#闭包的作用\" class=\"headerlink\" title=\"闭包的作用\"></a>闭包的作用</h4><ol>\n<li><strong>在函数外部访问这个函数的局部变量</strong></li>\n</ol>\n<p>在fnParent的外部，如果想直接访问fnParent的变量对象，是行不通的，这时候就需要用到闭包了，给fnParent的内部创建一个子函数fnChild，fnChild就是闭包，闭包将fnParent的内部和外部连接了起来。</p>\n<p>既然fnChild可以访问fnChild的局部变量，那么直接把fnChild作为fnParent的返回值，然后把fnChild赋值给一个全局变量，不就可以在fnParent外部通过这个全局变量来访问fnParent的局部变量了吗？！<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">function fnParent()&#123;</div><div class=\"line\">　var n=999;</div><div class=\"line\">　return　function fnChild()&#123;</div><div class=\"line\">　　　　alert(n);</div><div class=\"line\">　　&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">var a=fnParent();   //执行fnParent，并将返回值fnChild（即闭包）赋给全局变量a</div><div class=\"line\">a();    //执行a函数，访问 fnParent中的局部变量n</div></pre></td></tr></table></figure></p>\n<ol>\n<li><strong>让函数的局部变量一直保存在内存中不被销毁</strong></li>\n</ol>\n<p>当从fnParent中返回它的子函数fnChild时，fnChild就是闭包，如果把fnChild赋值给一个全局变量，fnChild就一直存在于内存中，而子函数fnChild的存在又依赖父函数fnParent,故父函数fnParent也始终存在于内存中，因此导致在fnParent执行完毕后，这个函数内的局部变量对象并不会被回收，直到闭包被销毁后，fnParent的变量对象才能被销毁。</p>\n<p>在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　function f1()&#123;</div><div class=\"line\">　　　　var n=999;</div><div class=\"line\">　　　　nAdd=function()&#123;n+=1&#125;</div><div class=\"line\">　　　　function f2()&#123;</div><div class=\"line\">　　　　　　alert(n);</div><div class=\"line\">　　　　&#125;</div><div class=\"line\">　　　　return f2;</div><div class=\"line\">　　&#125;</div><div class=\"line\">　　var result=f1();</div><div class=\"line\">　　result(); // 999</div><div class=\"line\">　　nAdd();</div><div class=\"line\">　　result(); // 1000</div></pre></td></tr></table></figure></p>\n<h5 id=\"总而言之，闭包就是一个定义在父函数中的函数，闭包除了是一个函数外，还保存着父函数的局部变量对象，使得在全局环境中调用闭包时还能访问父函数的变量，并且父函数的变量始终在内存中。\"><a href=\"#总而言之，闭包就是一个定义在父函数中的函数，闭包除了是一个函数外，还保存着父函数的局部变量对象，使得在全局环境中调用闭包时还能访问父函数的变量，并且父函数的变量始终在内存中。\" class=\"headerlink\" title=\"总而言之，闭包就是一个定义在父函数中的函数，闭包除了是一个函数外，还保存着父函数的局部变量对象，使得在全局环境中调用闭包时还能访问父函数的变量，并且父函数的变量始终在内存中。\"></a>总而言之，闭包就是一个定义在父函数中的函数，闭包除了是一个函数外，还保存着父函数的局部变量对象，使得在全局环境中调用闭包时还能访问父函数的变量，并且父函数的变量始终在内存中。</h5><h4 id=\"使用闭包的注意点\"><a href=\"#使用闭包的注意点\" class=\"headerlink\" title=\"使用闭包的注意点\"></a>使用闭包的注意点</h4><ul>\n<li><p>闭包保存的是父函数的整个变量对象（即引用），而不是某个具体的变量。当某个变量有多个值时，最后的值会覆盖前面的值，所以闭包只能取得父函数中任何变量的最后一个值。当闭包处在循环语句块的时候尤其要注意这一点。</p>\n<p>  例如下面的代码，我们的设想是我们点击按钮的时候，点击第一个按钮提示 “我是第0个按钮”，点击第二个按钮提示 “我是第1个按钮”，以此类推。但是事实上，当我们运行的时候就会发现，无论点击哪个按钮，都会提示：“我是第3个按钮”。每次循环的时候闭包要取得i的值，但是这里的i并不是一个具体的变量，而是一个变量对象（即引用），当某个变量有多个值时，最后的值会覆盖前面的值，所以在每个函数内部 i 的值都是 3 。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;body&gt;</div><div class=\"line\">    &lt;button&gt;我是第0个按钮&lt;/button&gt;</div><div class=\"line\">    &lt;button&gt;我是第1个按钮&lt;/button&gt;</div><div class=\"line\">    &lt;button&gt;我是第2个按钮&lt;/button&gt;</div><div class=\"line\">    &lt;script type=&quot;text/javascript&quot;&gt;</div><div class=\"line\">    window.onload=function () &#123;</div><div class=\"line\">        var btns = document.getElementsByTagName(&quot;button&quot;);</div><div class=\"line\">        for(var i = 0; i &lt; btns.length; i++)&#123;</div><div class=\"line\">            btns[i].onclick = function() &#123;</div><div class=\"line\">                alert(&quot;我是第&quot; + i + &quot;个按钮&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    &lt;/script&gt;</div><div class=\"line\">&lt;/body&gt;</div></pre></td></tr></table></figure>\n<p>解决方法是在这个闭包内创建一个匿名函数让闭包的行为符合预期。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">for(var i = 0; i &lt; btns.length; i++)&#123;</div><div class=\"line\">    btns[i].onclick = (function(num)&#123;</div><div class=\"line\">        return function() &#123; //在闭包内再设置一个匿名函数</div><div class=\"line\">            alert(&quot;我是第&quot; + num + &quot;个按钮&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;)(i);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li><p>闭包中的this对象：匿名函数的执行环境具有全局性，所以匿名函数的this通常指向window（不使用call(),apple(),bind()的情况下）。</p>\n<p>  在闭包中，匿名函数不会取得其父函数或者外部作用域的this对象，而是直接取它自己的this对象，因为每个函数在调用的时候都会自动取得两个特殊变量：this和arguments，闭包也不例外，既然闭包自己就有this(window)和arguments，那么何必去别的地方找呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var name =&apos;the Window&apos;;</div><div class=\"line\">var obj=&#123;</div><div class=\"line\">  name:&apos;zys&apos;,</div><div class=\"line\">  getName:function () &#123;</div><div class=\"line\">     return function () &#123;</div><div class=\"line\">      return this.name;     //这个匿名函数的this其实是window</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">alert(obj.getName()())      //弹出the Window</div></pre></td></tr></table></figure>\n<p>  如果想要匿名函数取得其父函数的this对象，可以把其父函数的this保存给一个闭包能访问到的变量</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">var name =&apos;the Window&apos;;</div><div class=\"line\">var obj=&#123;</div><div class=\"line\">  name:&apos;zys&apos;,</div><div class=\"line\">  getName:function () &#123;</div><div class=\"line\">     var that=this;     //把这个方法的this(即obj) 先保存给变量that</div><div class=\"line\">     return function () &#123;</div><div class=\"line\">      return that.name;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">alert(obj.getName()())      //弹出zys</div></pre></td></tr></table></figure>\n<ul>\n<li>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</li>\n<li>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象使用，把闭包当作它的公用方法，把内部变量当作它的私有属性，这时一定要小心，不要随便改变父函数内部变量的值。</li>\n</ul>\n<h3 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h3><ol>\n<li>@亓官翊宸  简书-JavaScript 中的作用域链（scope chain）和闭包<br><a href=\"http://www.jianshu.com/p/ac926e0d6811\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/ac926e0d6811</a></li>\n<li>@milter  简书-教你步步为营掌握JavaScript闭包<br><a href=\"http://www.jianshu.com/p/c63edc058504\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/c63edc058504</a></li>\n<li>阮一峰的网络日志- 学习Javascript闭包（Closure）<br><a href=\"http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html\" target=\"_blank\" rel=\"external\">http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html</a></li>\n</ol>\n","excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>闭包是JS的一大特色，最近在学习《javascript高级程序设计》的函数部分时，遇到了闭包，在查阅各种资料后有了以下的心得</p>\n<h4 id=\"什么是闭包？\"><a href=\"#什么是闭包？\" class=\"headerlink\" title=\"什么是闭包？\"></a>什么是闭包？</h4><p>闭包就是一个函数（不妨叫它fnChild），这个函数fnChild定义在它的父函数（fnParent）的内部，且能够读取fnParent的变量对象。</p>\n<h4 id=\"闭包的前提\"><a href=\"#闭包的前提\" class=\"headerlink\" title=\"闭包的前提\"></a>闭包的前提</h4><p>当函数fnParent的子函数fnChild被函数fnParent外的一个变量(通常是全局变量)引用的时候，就创建了一个我们通常所谓的“闭包”</p>\n<h4 id=\"闭包的作用\"><a href=\"#闭包的作用\" class=\"headerlink\" title=\"闭包的作用\"></a>闭包的作用</h4><ol>\n<li><strong>在函数外部访问这个函数的局部变量</strong></li>\n</ol>\n<p>在fnParent的外部，如果想直接访问fnParent的变量对象，是行不通的，这时候就需要用到闭包了，给fnParent的内部创建一个子函数fnChild，fnChild就是闭包，闭包将fnParent的内部和外部连接了起来。</p>\n<p>既然fnChild可以访问fnChild的局部变量，那么直接把fnChild作为fnParent的返回值，然后把fnChild赋值给一个全局变量，不就可以在fnParent外部通过这个全局变量来访问fnParent的局部变量了吗？！<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">function fnParent()&#123;</div><div class=\"line\">　var n=999;</div><div class=\"line\">　return　function fnChild()&#123;</div><div class=\"line\">　　　　alert(n);</div><div class=\"line\">　　&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">var a=fnParent();   //执行fnParent，并将返回值fnChild（即闭包）赋给全局变量a</div><div class=\"line\">a();    //执行a函数，访问 fnParent中的局部变量n</div></pre></td></tr></table></figure></p>\n<ol>\n<li><strong>让函数的局部变量一直保存在内存中不被销毁</strong></li>\n</ol>\n<p>当从fnParent中返回它的子函数fnChild时，fnChild就是闭包，如果把fnChild赋值给一个全局变量，fnChild就一直存在于内存中，而子函数fnChild的存在又依赖父函数fnParent,故父函数fnParent也始终存在于内存中，因此导致在fnParent执行完毕后，这个函数内的局部变量对象并不会被回收，直到闭包被销毁后，fnParent的变量对象才能被销毁。</p>\n<p>在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　function f1()&#123;</div><div class=\"line\">　　　　var n=999;</div><div class=\"line\">　　　　nAdd=function()&#123;n+=1&#125;</div><div class=\"line\">　　　　function f2()&#123;</div><div class=\"line\">　　　　　　alert(n);</div><div class=\"line\">　　　　&#125;</div><div class=\"line\">　　　　return f2;</div><div class=\"line\">　　&#125;</div><div class=\"line\">　　var result=f1();</div><div class=\"line\">　　result(); // 999</div><div class=\"line\">　　nAdd();</div><div class=\"line\">　　result(); // 1000</div></pre></td></tr></table></figure></p>\n<h5 id=\"总而言之，闭包就是一个定义在父函数中的函数，闭包除了是一个函数外，还保存着父函数的局部变量对象，使得在全局环境中调用闭包时还能访问父函数的变量，并且父函数的变量始终在内存中。\"><a href=\"#总而言之，闭包就是一个定义在父函数中的函数，闭包除了是一个函数外，还保存着父函数的局部变量对象，使得在全局环境中调用闭包时还能访问父函数的变量，并且父函数的变量始终在内存中。\" class=\"headerlink\" title=\"总而言之，闭包就是一个定义在父函数中的函数，闭包除了是一个函数外，还保存着父函数的局部变量对象，使得在全局环境中调用闭包时还能访问父函数的变量，并且父函数的变量始终在内存中。\"></a>总而言之，闭包就是一个定义在父函数中的函数，闭包除了是一个函数外，还保存着父函数的局部变量对象，使得在全局环境中调用闭包时还能访问父函数的变量，并且父函数的变量始终在内存中。</h5><h4 id=\"使用闭包的注意点\"><a href=\"#使用闭包的注意点\" class=\"headerlink\" title=\"使用闭包的注意点\"></a>使用闭包的注意点</h4><ul>\n<li><p>闭包保存的是父函数的整个变量对象（即引用），而不是某个具体的变量。当某个变量有多个值时，最后的值会覆盖前面的值，所以闭包只能取得父函数中任何变量的最后一个值。当闭包处在循环语句块的时候尤其要注意这一点。</p>\n<p>  例如下面的代码，我们的设想是我们点击按钮的时候，点击第一个按钮提示 “我是第0个按钮”，点击第二个按钮提示 “我是第1个按钮”，以此类推。但是事实上，当我们运行的时候就会发现，无论点击哪个按钮，都会提示：“我是第3个按钮”。每次循环的时候闭包要取得i的值，但是这里的i并不是一个具体的变量，而是一个变量对象（即引用），当某个变量有多个值时，最后的值会覆盖前面的值，所以在每个函数内部 i 的值都是 3 。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;body&gt;</div><div class=\"line\">    &lt;button&gt;我是第0个按钮&lt;/button&gt;</div><div class=\"line\">    &lt;button&gt;我是第1个按钮&lt;/button&gt;</div><div class=\"line\">    &lt;button&gt;我是第2个按钮&lt;/button&gt;</div><div class=\"line\">    &lt;script type=&quot;text/javascript&quot;&gt;</div><div class=\"line\">    window.onload=function () &#123;</div><div class=\"line\">        var btns = document.getElementsByTagName(&quot;button&quot;);</div><div class=\"line\">        for(var i = 0; i &lt; btns.length; i++)&#123;</div><div class=\"line\">            btns[i].onclick = function() &#123;</div><div class=\"line\">                alert(&quot;我是第&quot; + i + &quot;个按钮&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    &lt;/script&gt;</div><div class=\"line\">&lt;/body&gt;</div></pre></td></tr></table></figure>\n<p>解决方法是在这个闭包内创建一个匿名函数让闭包的行为符合预期。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">for(var i = 0; i &lt; btns.length; i++)&#123;</div><div class=\"line\">    btns[i].onclick = (function(num)&#123;</div><div class=\"line\">        return function() &#123; //在闭包内再设置一个匿名函数</div><div class=\"line\">            alert(&quot;我是第&quot; + num + &quot;个按钮&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;)(i);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li><p>闭包中的this对象：匿名函数的执行环境具有全局性，所以匿名函数的this通常指向window（不使用call(),apple(),bind()的情况下）。</p>\n<p>  在闭包中，匿名函数不会取得其父函数或者外部作用域的this对象，而是直接取它自己的this对象，因为每个函数在调用的时候都会自动取得两个特殊变量：this和arguments，闭包也不例外，既然闭包自己就有this(window)和arguments，那么何必去别的地方找呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var name =&apos;the Window&apos;;</div><div class=\"line\">var obj=&#123;</div><div class=\"line\">  name:&apos;zys&apos;,</div><div class=\"line\">  getName:function () &#123;</div><div class=\"line\">     return function () &#123;</div><div class=\"line\">      return this.name;     //这个匿名函数的this其实是window</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">alert(obj.getName()())      //弹出the Window</div></pre></td></tr></table></figure>\n<p>  如果想要匿名函数取得其父函数的this对象，可以把其父函数的this保存给一个闭包能访问到的变量</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">var name =&apos;the Window&apos;;</div><div class=\"line\">var obj=&#123;</div><div class=\"line\">  name:&apos;zys&apos;,</div><div class=\"line\">  getName:function () &#123;</div><div class=\"line\">     var that=this;     //把这个方法的this(即obj) 先保存给变量that</div><div class=\"line\">     return function () &#123;</div><div class=\"line\">      return that.name;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">alert(obj.getName()())      //弹出zys</div></pre></td></tr></table></figure>\n<ul>\n<li>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</li>\n<li>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象使用，把闭包当作它的公用方法，把内部变量当作它的私有属性，这时一定要小心，不要随便改变父函数内部变量的值。</li>\n</ul>\n<h3 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h3><ol>\n<li>@亓官翊宸  简书-JavaScript 中的作用域链（scope chain）和闭包<br><a href=\"http://www.jianshu.com/p/ac926e0d6811\">http://www.jianshu.com/p/ac926e0d6811</a></li>\n<li>@milter  简书-教你步步为营掌握JavaScript闭包<br><a href=\"http://www.jianshu.com/p/c63edc058504\">http://www.jianshu.com/p/c63edc058504</a></li>\n<li>阮一峰的网络日志- 学习Javascript闭包（Closure）<br><a href=\"http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html\">http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html</a></li>\n</ol>\n"},{"title":"基本类型值和引用类型值","date":"2016-12-22T01:37:08.000Z","_content":"### 什么是变量\n先看看到底什么是变量？在JS中，变量仅仅是一个用来保存值的占位符而已，变量占据一定的内存位置，里面保存着值。可以理解为是一个盒子，盒子里面可以装各种东西，盒子的名字就叫变量名。\n\n### 什么是基本类型值和引用类型值\njavascript的变量可能有两个不同类型的值：基本类型值和引用类型值。\n\n基本类型值指简单的数据段，包括Undifined、Null、Boolean、Number和String。\n\n引用类型的值指那些可能由多个值构成的**对象**，包括Object、Array、Date、RegExp、Funciton等。 \n\n   \n\n### 不同之处：\n1. 大小不同：\n    * 基本类型的值大小固定，一般都比较小；\n    * 引用类型的值大小不固定，一般比较大。\n2. 保存位置不同：\n    * 基本类型的值保存在栈中\n    * 引用类型的值保存在堆中，引用保存在栈中\n    \n    关于堆和栈的区别：栈中保存的是基本类型的值以及引用类型值的引用，大小固定，按值访问；而引用类型的值大小不固定，所以要保存在堆中，不能直接保存在栈中，但是可以把地址（即引用，或者指针）保存在栈中。图中，连接栈中Object类型与堆中Object的线就是引用。\n![image](http://img1.tuicool.com/nIVVNza.png!web)\n3. 访问方式不同：\n    * 基本类型的值，可以直接操作保存在变量中的实际值，即可以直接访问变量所占的内存位置，所以基本类型的值是按值访问的。\n    * 引用类型的值是保存在内存中的对象。与基本类型的值不同，引用类型的值中，js不允许直接访问内存位置，也就是说不能直接操作对象的内存空间，在操作对象的时候实际上都是在操作对象的引用而不是实际的对象，所以引用类型的值都是按引用访问的。\n    \n\n    何为引用？引用传递的是对象的在内存空间中的地址。\n    何为按引用访问？就相当于访问对象的地址（指针），而不是直接访问对象\n\n4. 只能给引用类型值动态的添加属性和方法，而不能给基本类型值添加属性和方法。\n5. 复制变量值时的不同：\n    * 基本类型的值：因为基本类型值是按值访问的，所以在从一个变量向另外一个变量复制基本类型值的时候，会重新创建一个新的内存空间用来存新变量的值。新变量和原来的变量虽然值一样，但是确是两个相互独立的变量，互不影响，因为他们的内存位置不一样。\n    * 引用类型的值：因为引用类型值是按引用访问的，所以在从一个变量向另外一个变量复制引用类型值的时候，复制的其实是这个对象在内存中的地址（指针）。复制结束后，两个变量实际上都引用同一个对象，或者说两个变量的指针都指向这个对象。因此两个变量是会互相影响的，改变其中一个变量，实际上是改变了内存中的对象，另外一个变量也会相应的改变。\n    \n```\nvar obj1=new Object();\nvar obj2=obj1;\nobj1.name='zys';\nalert(obj2.name);           //弹出‘zys’，因为obj1和obj2都指向同一个内存空间\n```\n6. 给函数传递参数时的不同：函数传参是按值传递的，传参的过程实际就是把函数外部的值复制给函数内部的参数的过程，就和把值从一个变量复制到另外一个变量一样。\n    * 基本类型的值：传参时，若参数为基本类型值，被传递的值会被复制为arguments的一个元素。\n    * 引用类型的值：传参时，若参数为引用类型值，被传递的值的引用会被复制为arguments的一个元素，因此若这个arguments元素发生变化，则内存中的对象也会被改变，相应的原变量也会改变。\n   \n\n    \n\n","source":"_posts/基本类型值和引用类型值.md","raw":"---\ntitle: 基本类型值和引用类型值\ndate: 2016-12-22 09:37:08\ntags: 学习心得\n---\n### 什么是变量\n先看看到底什么是变量？在JS中，变量仅仅是一个用来保存值的占位符而已，变量占据一定的内存位置，里面保存着值。可以理解为是一个盒子，盒子里面可以装各种东西，盒子的名字就叫变量名。\n\n### 什么是基本类型值和引用类型值\njavascript的变量可能有两个不同类型的值：基本类型值和引用类型值。\n\n基本类型值指简单的数据段，包括Undifined、Null、Boolean、Number和String。\n\n引用类型的值指那些可能由多个值构成的**对象**，包括Object、Array、Date、RegExp、Funciton等。 \n\n   \n\n### 不同之处：\n1. 大小不同：\n    * 基本类型的值大小固定，一般都比较小；\n    * 引用类型的值大小不固定，一般比较大。\n2. 保存位置不同：\n    * 基本类型的值保存在栈中\n    * 引用类型的值保存在堆中，引用保存在栈中\n    \n    关于堆和栈的区别：栈中保存的是基本类型的值以及引用类型值的引用，大小固定，按值访问；而引用类型的值大小不固定，所以要保存在堆中，不能直接保存在栈中，但是可以把地址（即引用，或者指针）保存在栈中。图中，连接栈中Object类型与堆中Object的线就是引用。\n![image](http://img1.tuicool.com/nIVVNza.png!web)\n3. 访问方式不同：\n    * 基本类型的值，可以直接操作保存在变量中的实际值，即可以直接访问变量所占的内存位置，所以基本类型的值是按值访问的。\n    * 引用类型的值是保存在内存中的对象。与基本类型的值不同，引用类型的值中，js不允许直接访问内存位置，也就是说不能直接操作对象的内存空间，在操作对象的时候实际上都是在操作对象的引用而不是实际的对象，所以引用类型的值都是按引用访问的。\n    \n\n    何为引用？引用传递的是对象的在内存空间中的地址。\n    何为按引用访问？就相当于访问对象的地址（指针），而不是直接访问对象\n\n4. 只能给引用类型值动态的添加属性和方法，而不能给基本类型值添加属性和方法。\n5. 复制变量值时的不同：\n    * 基本类型的值：因为基本类型值是按值访问的，所以在从一个变量向另外一个变量复制基本类型值的时候，会重新创建一个新的内存空间用来存新变量的值。新变量和原来的变量虽然值一样，但是确是两个相互独立的变量，互不影响，因为他们的内存位置不一样。\n    * 引用类型的值：因为引用类型值是按引用访问的，所以在从一个变量向另外一个变量复制引用类型值的时候，复制的其实是这个对象在内存中的地址（指针）。复制结束后，两个变量实际上都引用同一个对象，或者说两个变量的指针都指向这个对象。因此两个变量是会互相影响的，改变其中一个变量，实际上是改变了内存中的对象，另外一个变量也会相应的改变。\n    \n```\nvar obj1=new Object();\nvar obj2=obj1;\nobj1.name='zys';\nalert(obj2.name);           //弹出‘zys’，因为obj1和obj2都指向同一个内存空间\n```\n6. 给函数传递参数时的不同：函数传参是按值传递的，传参的过程实际就是把函数外部的值复制给函数内部的参数的过程，就和把值从一个变量复制到另外一个变量一样。\n    * 基本类型的值：传参时，若参数为基本类型值，被传递的值会被复制为arguments的一个元素。\n    * 引用类型的值：传参时，若参数为引用类型值，被传递的值的引用会被复制为arguments的一个元素，因此若这个arguments元素发生变化，则内存中的对象也会被改变，相应的原变量也会改变。\n   \n\n    \n\n","slug":"基本类型值和引用类型值","published":1,"updated":"2017-01-17T15:08:23.579Z","_id":"cix1x8utu0000pk51hns8siou","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"什么是变量\"><a href=\"#什么是变量\" class=\"headerlink\" title=\"什么是变量\"></a>什么是变量</h3><p>先看看到底什么是变量？在JS中，变量仅仅是一个用来保存值的占位符而已，变量占据一定的内存位置，里面保存着值。可以理解为是一个盒子，盒子里面可以装各种东西，盒子的名字就叫变量名。</p>\n<h3 id=\"什么是基本类型值和引用类型值\"><a href=\"#什么是基本类型值和引用类型值\" class=\"headerlink\" title=\"什么是基本类型值和引用类型值\"></a>什么是基本类型值和引用类型值</h3><p>javascript的变量可能有两个不同类型的值：基本类型值和引用类型值。</p>\n<p>基本类型值指简单的数据段，包括Undifined、Null、Boolean、Number和String。</p>\n<p>引用类型的值指那些可能由多个值构成的<strong>对象</strong>，包括Object、Array、Date、RegExp、Funciton等。 </p>\n<h3 id=\"不同之处：\"><a href=\"#不同之处：\" class=\"headerlink\" title=\"不同之处：\"></a>不同之处：</h3><ol>\n<li>大小不同：<ul>\n<li>基本类型的值大小固定，一般都比较小；</li>\n<li>引用类型的值大小不固定，一般比较大。</li>\n</ul>\n</li>\n<li><p>保存位置不同：</p>\n<ul>\n<li>基本类型的值保存在栈中</li>\n<li><p>引用类型的值保存在堆中，引用保存在栈中</p>\n<p>关于堆和栈的区别：栈中保存的是基本类型的值以及引用类型值的引用，大小固定，按值访问；而引用类型的值大小不固定，所以要保存在堆中，不能直接保存在栈中，但是可以把地址（即引用，或者指针）保存在栈中。图中，连接栈中Object类型与堆中Object的线就是引用。<br><img src=\"http://img1.tuicool.com/nIVVNza.png!web\" alt=\"image\"></p>\n</li>\n</ul>\n</li>\n<li>访问方式不同：<ul>\n<li>基本类型的值，可以直接操作保存在变量中的实际值，即可以直接访问变量所占的内存位置，所以基本类型的值是按值访问的。</li>\n<li>引用类型的值是保存在内存中的对象。与基本类型的值不同，引用类型的值中，js不允许直接访问内存位置，也就是说不能直接操作对象的内存空间，在操作对象的时候实际上都是在操作对象的引用而不是实际的对象，所以引用类型的值都是按引用访问的。</li>\n</ul>\n</li>\n</ol>\n<pre><code>何为引用？引用传递的是对象的在内存空间中的地址。\n何为按引用访问？就相当于访问对象的地址（指针），而不是直接访问对象\n</code></pre><ol>\n<li>只能给引用类型值动态的添加属性和方法，而不能给基本类型值添加属性和方法。</li>\n<li>复制变量值时的不同：<ul>\n<li>基本类型的值：因为基本类型值是按值访问的，所以在从一个变量向另外一个变量复制基本类型值的时候，会重新创建一个新的内存空间用来存新变量的值。新变量和原来的变量虽然值一样，但是确是两个相互独立的变量，互不影响，因为他们的内存位置不一样。</li>\n<li>引用类型的值：因为引用类型值是按引用访问的，所以在从一个变量向另外一个变量复制引用类型值的时候，复制的其实是这个对象在内存中的地址（指针）。复制结束后，两个变量实际上都引用同一个对象，或者说两个变量的指针都指向这个对象。因此两个变量是会互相影响的，改变其中一个变量，实际上是改变了内存中的对象，另外一个变量也会相应的改变。</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var obj1=new Object();</div><div class=\"line\">var obj2=obj1;</div><div class=\"line\">obj1.name=&apos;zys&apos;;</div><div class=\"line\">alert(obj2.name);           //弹出‘zys’，因为obj1和obj2都指向同一个内存空间</div></pre></td></tr></table></figure>\n<ol>\n<li>给函数传递参数时的不同：函数传参是按值传递的，传参的过程实际就是把函数外部的值复制给函数内部的参数的过程，就和把值从一个变量复制到另外一个变量一样。<ul>\n<li>基本类型的值：传参时，若参数为基本类型值，被传递的值会被复制为arguments的一个元素。</li>\n<li>引用类型的值：传参时，若参数为引用类型值，被传递的值的引用会被复制为arguments的一个元素，因此若这个arguments元素发生变化，则内存中的对象也会被改变，相应的原变量也会改变。</li>\n</ul>\n</li>\n</ol>\n","excerpt":"","more":"<h3 id=\"什么是变量\"><a href=\"#什么是变量\" class=\"headerlink\" title=\"什么是变量\"></a>什么是变量</h3><p>先看看到底什么是变量？在JS中，变量仅仅是一个用来保存值的占位符而已，变量占据一定的内存位置，里面保存着值。可以理解为是一个盒子，盒子里面可以装各种东西，盒子的名字就叫变量名。</p>\n<h3 id=\"什么是基本类型值和引用类型值\"><a href=\"#什么是基本类型值和引用类型值\" class=\"headerlink\" title=\"什么是基本类型值和引用类型值\"></a>什么是基本类型值和引用类型值</h3><p>javascript的变量可能有两个不同类型的值：基本类型值和引用类型值。</p>\n<p>基本类型值指简单的数据段，包括Undifined、Null、Boolean、Number和String。</p>\n<p>引用类型的值指那些可能由多个值构成的<strong>对象</strong>，包括Object、Array、Date、RegExp、Funciton等。 </p>\n<h3 id=\"不同之处：\"><a href=\"#不同之处：\" class=\"headerlink\" title=\"不同之处：\"></a>不同之处：</h3><ol>\n<li>大小不同：<ul>\n<li>基本类型的值大小固定，一般都比较小；</li>\n<li>引用类型的值大小不固定，一般比较大。</li>\n</ul>\n</li>\n<li><p>保存位置不同：</p>\n<ul>\n<li>基本类型的值保存在栈中</li>\n<li><p>引用类型的值保存在堆中，引用保存在栈中</p>\n<p>关于堆和栈的区别：栈中保存的是基本类型的值以及引用类型值的引用，大小固定，按值访问；而引用类型的值大小不固定，所以要保存在堆中，不能直接保存在栈中，但是可以把地址（即引用，或者指针）保存在栈中。图中，连接栈中Object类型与堆中Object的线就是引用。<br><img src=\"http://img1.tuicool.com/nIVVNza.png!web\" alt=\"image\"></p>\n</li>\n</ul>\n</li>\n<li>访问方式不同：<ul>\n<li>基本类型的值，可以直接操作保存在变量中的实际值，即可以直接访问变量所占的内存位置，所以基本类型的值是按值访问的。</li>\n<li>引用类型的值是保存在内存中的对象。与基本类型的值不同，引用类型的值中，js不允许直接访问内存位置，也就是说不能直接操作对象的内存空间，在操作对象的时候实际上都是在操作对象的引用而不是实际的对象，所以引用类型的值都是按引用访问的。</li>\n</ul>\n</li>\n</ol>\n<pre><code>何为引用？引用传递的是对象的在内存空间中的地址。\n何为按引用访问？就相当于访问对象的地址（指针），而不是直接访问对象\n</code></pre><ol>\n<li>只能给引用类型值动态的添加属性和方法，而不能给基本类型值添加属性和方法。</li>\n<li>复制变量值时的不同：<ul>\n<li>基本类型的值：因为基本类型值是按值访问的，所以在从一个变量向另外一个变量复制基本类型值的时候，会重新创建一个新的内存空间用来存新变量的值。新变量和原来的变量虽然值一样，但是确是两个相互独立的变量，互不影响，因为他们的内存位置不一样。</li>\n<li>引用类型的值：因为引用类型值是按引用访问的，所以在从一个变量向另外一个变量复制引用类型值的时候，复制的其实是这个对象在内存中的地址（指针）。复制结束后，两个变量实际上都引用同一个对象，或者说两个变量的指针都指向这个对象。因此两个变量是会互相影响的，改变其中一个变量，实际上是改变了内存中的对象，另外一个变量也会相应的改变。</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var obj1=new Object();</div><div class=\"line\">var obj2=obj1;</div><div class=\"line\">obj1.name=&apos;zys&apos;;</div><div class=\"line\">alert(obj2.name);           //弹出‘zys’，因为obj1和obj2都指向同一个内存空间</div></pre></td></tr></table></figure>\n<ol>\n<li>给函数传递参数时的不同：函数传参是按值传递的，传参的过程实际就是把函数外部的值复制给函数内部的参数的过程，就和把值从一个变量复制到另外一个变量一样。<ul>\n<li>基本类型的值：传参时，若参数为基本类型值，被传递的值会被复制为arguments的一个元素。</li>\n<li>引用类型的值：传参时，若参数为引用类型值，被传递的值的引用会被复制为arguments的一个元素，因此若这个arguments元素发生变化，则内存中的对象也会被改变，相应的原变量也会改变。</li>\n</ul>\n</li>\n</ol>\n"},{"title":"Function类型小结","date":"2016-12-23T01:37:08.000Z","_content":"### 什么是Function类型\n之前已经说过，变量的值有基本类型值和引用类型值，而Function类型就属于引用类型值的一种。说白了，Function类型就是函数。由于引用类型都是对象，所以函数实际上也是对象。既然是对象，就和其他引用类型一样有自己的属性和方法。既然是引用类型的值，函数名实际上也是一个指向函数的指针，而不会与某个函数绑定。\n### 没有重载\n因为函数名是指针，指向函数对象，所以当有几个函数名一模一样时，后面的会覆盖前面的函数，这个指针最终只指向最后一个函数对象。\n### 定义函数的两种方法\n1. 函数声明，格式如下\n```\nfunction function_name(arg0,arg1,arg2,...) {\n        //函数体    \n}\n```\n函数声明的重要特性就**是函数声明提升**，意思是系统在执行代码时会先读取函数声明，这样就可以把函数声明放在调用它的语句之后了。\n2. 函数表达式\n\n最常见的就是先创建一个匿名函数然后将这个匿名函数赋值给一个变量，变量名就是函数名。\n\n```\nvar function_name=function (arg0,arg1,arg2,...) {\n    //函数体 \n}\n```\n\n匿名函数有一个重要特性就是，匿名函数的执行环境是全局环境，也就是说匿名函数里的this总是指window.\n### 函数内部属性\n每个函数内部都有两个特殊的对象：arguments和this\n* arguments对象：类似数组，包含着传入函数的所有参数。arguments有一个属性callee，该属性是一个指针，指向拥有这个arguments对象的函数，即指向正在执行的函数。\n比较经典的例子就是递归函数。\n\n    递归函数是在一个函数通过名字调用自身的情况下构成的。在递归函数中，这样的做法会使函数的执行与函数名紧紧耦合在了一起，为了降低耦合度，一般用arguments.callee 来代替函数体中的函数名，arguments.callee是一个指向正在执行的函数的指针。这样即使执行函数的时候函数名发生了变化，也可以正常执行。\n\n```\nfunction factorial(num) {\n    if (num<=1) {\n        return 1;\n    } else {\n        return num*arguments.callee(num-1);     //用argument.callee代替函数名factorial\n    }\n}\n```\n* this对象：简单的说，当前方法或者函数属于谁，this就是谁。全局函数的this是window。\n### 函数属性\n每个函数都包含两个属性：length和prototype。\n\n* length属性表示函数希望接受的命名参数的个数，即函数定义时圆括号里的参数个数。\n* prototype属性在创建自定义引用类型以及实现继承时极为重要，prototype属性的不可枚举的，使用for-in无法发现\n### 函数方法：\n每个函数都包含apply()和call()方法，这两个方法是非继承的，也就是说是每个函数都自带的。\n* apply()和call()方法的功能完全一样，都是把当前函数的this对象强行变成apply()或者call()方法的第一个参数。圆括号里从第二个参数开始才是原函数真正的参数。函数绑定了apply()或者call()方法后，立即执行。\n\n```\nwindow.color='red';\nvar obj1={ color:'blue'; }\nfunction sayColor( ) {\n    alert (this.color); //全局函数，this就是window\n}\nsayColor();//   弹出red\n\n// 绑定call()或apply()后函数立即执行\nsayColor.call(this);//弹出red,把原函数的this(window)变成了全局环境的this(window)，其实this本身没有改变，仍然是window\nsayColor.call(window);//弹出red,把原函数的this(window)变成了window，其实this本身没有改变，仍然是window\nsayColor.call(obj1);//弹出blue，把原函数的this(window)变成了obj1,而obj1.color就是blue\n```\n\n* apply()和call()方法的区别：接受参数的方式不同。\n    * apply()的第一个参数是要改变的this，第二个参数是保存真正参数的数组arguments，也可以是一个具体的由参数组成的数组。\n    * call()的第一个参数是要改变的this，从第二个开始，是原函数真正的参数，且传递的参数必须逐个列举出来\n    \n```\n//以下两种apple()方法的传参方式等价\nfunction_name.apply(this,arguments);\nfunction_name.apply(this,[arg0,arg1,arg2,...]);\n\n//以下是call()方法的传参方式：\nfunction_name.call(this,arg0,arg1,arg2,...);\n```\n* bind()方法：作用类似与apply()和call()方法，但是不会立即执行。会返回一个函数，这个返回的函数的this值会被绑定为bind()的参数。\n\n```\nwindow.color='red';\nvar obj1={ color:'blue'; }\nfunction sayColor( ) {\n    alert (this.color); //全局函数，this就是window\n}\nvar objectSayColor=sayColor.bind(obj1); // 返回一个函数，这个函数的this就是bind()括号里的参数obj1\nobjectSayColor();       //执行这个返回函数，this.color就是obj1.color,弹出blue\n```\n### 闭包\n见本博客中的《闭包小结》\n### ","source":"_posts/Function类型小结.md","raw":"---\ntitle: Function类型小结\ndate: 2016-12-23 09:37:08\ntags: 学习心得\n---\n### 什么是Function类型\n之前已经说过，变量的值有基本类型值和引用类型值，而Function类型就属于引用类型值的一种。说白了，Function类型就是函数。由于引用类型都是对象，所以函数实际上也是对象。既然是对象，就和其他引用类型一样有自己的属性和方法。既然是引用类型的值，函数名实际上也是一个指向函数的指针，而不会与某个函数绑定。\n### 没有重载\n因为函数名是指针，指向函数对象，所以当有几个函数名一模一样时，后面的会覆盖前面的函数，这个指针最终只指向最后一个函数对象。\n### 定义函数的两种方法\n1. 函数声明，格式如下\n```\nfunction function_name(arg0,arg1,arg2,...) {\n        //函数体    \n}\n```\n函数声明的重要特性就**是函数声明提升**，意思是系统在执行代码时会先读取函数声明，这样就可以把函数声明放在调用它的语句之后了。\n2. 函数表达式\n\n最常见的就是先创建一个匿名函数然后将这个匿名函数赋值给一个变量，变量名就是函数名。\n\n```\nvar function_name=function (arg0,arg1,arg2,...) {\n    //函数体 \n}\n```\n\n匿名函数有一个重要特性就是，匿名函数的执行环境是全局环境，也就是说匿名函数里的this总是指window.\n### 函数内部属性\n每个函数内部都有两个特殊的对象：arguments和this\n* arguments对象：类似数组，包含着传入函数的所有参数。arguments有一个属性callee，该属性是一个指针，指向拥有这个arguments对象的函数，即指向正在执行的函数。\n比较经典的例子就是递归函数。\n\n    递归函数是在一个函数通过名字调用自身的情况下构成的。在递归函数中，这样的做法会使函数的执行与函数名紧紧耦合在了一起，为了降低耦合度，一般用arguments.callee 来代替函数体中的函数名，arguments.callee是一个指向正在执行的函数的指针。这样即使执行函数的时候函数名发生了变化，也可以正常执行。\n\n```\nfunction factorial(num) {\n    if (num<=1) {\n        return 1;\n    } else {\n        return num*arguments.callee(num-1);     //用argument.callee代替函数名factorial\n    }\n}\n```\n* this对象：简单的说，当前方法或者函数属于谁，this就是谁。全局函数的this是window。\n### 函数属性\n每个函数都包含两个属性：length和prototype。\n\n* length属性表示函数希望接受的命名参数的个数，即函数定义时圆括号里的参数个数。\n* prototype属性在创建自定义引用类型以及实现继承时极为重要，prototype属性的不可枚举的，使用for-in无法发现\n### 函数方法：\n每个函数都包含apply()和call()方法，这两个方法是非继承的，也就是说是每个函数都自带的。\n* apply()和call()方法的功能完全一样，都是把当前函数的this对象强行变成apply()或者call()方法的第一个参数。圆括号里从第二个参数开始才是原函数真正的参数。函数绑定了apply()或者call()方法后，立即执行。\n\n```\nwindow.color='red';\nvar obj1={ color:'blue'; }\nfunction sayColor( ) {\n    alert (this.color); //全局函数，this就是window\n}\nsayColor();//   弹出red\n\n// 绑定call()或apply()后函数立即执行\nsayColor.call(this);//弹出red,把原函数的this(window)变成了全局环境的this(window)，其实this本身没有改变，仍然是window\nsayColor.call(window);//弹出red,把原函数的this(window)变成了window，其实this本身没有改变，仍然是window\nsayColor.call(obj1);//弹出blue，把原函数的this(window)变成了obj1,而obj1.color就是blue\n```\n\n* apply()和call()方法的区别：接受参数的方式不同。\n    * apply()的第一个参数是要改变的this，第二个参数是保存真正参数的数组arguments，也可以是一个具体的由参数组成的数组。\n    * call()的第一个参数是要改变的this，从第二个开始，是原函数真正的参数，且传递的参数必须逐个列举出来\n    \n```\n//以下两种apple()方法的传参方式等价\nfunction_name.apply(this,arguments);\nfunction_name.apply(this,[arg0,arg1,arg2,...]);\n\n//以下是call()方法的传参方式：\nfunction_name.call(this,arg0,arg1,arg2,...);\n```\n* bind()方法：作用类似与apply()和call()方法，但是不会立即执行。会返回一个函数，这个返回的函数的this值会被绑定为bind()的参数。\n\n```\nwindow.color='red';\nvar obj1={ color:'blue'; }\nfunction sayColor( ) {\n    alert (this.color); //全局函数，this就是window\n}\nvar objectSayColor=sayColor.bind(obj1); // 返回一个函数，这个函数的this就是bind()括号里的参数obj1\nobjectSayColor();       //执行这个返回函数，this.color就是obj1.color,弹出blue\n```\n### 闭包\n见本博客中的《闭包小结》\n### ","slug":"Function类型小结","published":1,"updated":"2017-01-17T15:08:23.577Z","_id":"cix2oeylw00000g5165onlozo","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"什么是Function类型\"><a href=\"#什么是Function类型\" class=\"headerlink\" title=\"什么是Function类型\"></a>什么是Function类型</h3><p>之前已经说过，变量的值有基本类型值和引用类型值，而Function类型就属于引用类型值的一种。说白了，Function类型就是函数。由于引用类型都是对象，所以函数实际上也是对象。既然是对象，就和其他引用类型一样有自己的属性和方法。既然是引用类型的值，函数名实际上也是一个指向函数的指针，而不会与某个函数绑定。</p>\n<h3 id=\"没有重载\"><a href=\"#没有重载\" class=\"headerlink\" title=\"没有重载\"></a>没有重载</h3><p>因为函数名是指针，指向函数对象，所以当有几个函数名一模一样时，后面的会覆盖前面的函数，这个指针最终只指向最后一个函数对象。</p>\n<h3 id=\"定义函数的两种方法\"><a href=\"#定义函数的两种方法\" class=\"headerlink\" title=\"定义函数的两种方法\"></a>定义函数的两种方法</h3><ol>\n<li>函数声明，格式如下<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">function function_name(arg0,arg1,arg2,...) &#123;</div><div class=\"line\">        //函数体    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>函数声明的重要特性就<strong>是函数声明提升</strong>，意思是系统在执行代码时会先读取函数声明，这样就可以把函数声明放在调用它的语句之后了。</p>\n<ol>\n<li>函数表达式</li>\n</ol>\n<p>最常见的就是先创建一个匿名函数然后将这个匿名函数赋值给一个变量，变量名就是函数名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var function_name=function (arg0,arg1,arg2,...) &#123;</div><div class=\"line\">    //函数体 </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>匿名函数有一个重要特性就是，匿名函数的执行环境是全局环境，也就是说匿名函数里的this总是指window.</p>\n<h3 id=\"函数内部属性\"><a href=\"#函数内部属性\" class=\"headerlink\" title=\"函数内部属性\"></a>函数内部属性</h3><p>每个函数内部都有两个特殊的对象：arguments和this</p>\n<ul>\n<li><p>arguments对象：类似数组，包含着传入函数的所有参数。arguments有一个属性callee，该属性是一个指针，指向拥有这个arguments对象的函数，即指向正在执行的函数。<br>比较经典的例子就是递归函数。</p>\n<p>  递归函数是在一个函数通过名字调用自身的情况下构成的。在递归函数中，这样的做法会使函数的执行与函数名紧紧耦合在了一起，为了降低耦合度，一般用arguments.callee 来代替函数体中的函数名，arguments.callee是一个指向正在执行的函数的指针。这样即使执行函数的时候函数名发生了变化，也可以正常执行。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function factorial(num) &#123;</div><div class=\"line\">    if (num&lt;=1) &#123;</div><div class=\"line\">        return 1;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        return num*arguments.callee(num-1);     //用argument.callee代替函数名factorial</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>this对象：简单的说，当前方法或者函数属于谁，this就是谁。全局函数的this是window。</p>\n<h3 id=\"函数属性\"><a href=\"#函数属性\" class=\"headerlink\" title=\"函数属性\"></a>函数属性</h3><p>每个函数都包含两个属性：length和prototype。</p>\n</li>\n<li><p>length属性表示函数希望接受的命名参数的个数，即函数定义时圆括号里的参数个数。</p>\n</li>\n<li>prototype属性在创建自定义引用类型以及实现继承时极为重要，prototype属性的不可枚举的，使用for-in无法发现<h3 id=\"函数方法：\"><a href=\"#函数方法：\" class=\"headerlink\" title=\"函数方法：\"></a>函数方法：</h3>每个函数都包含apply()和call()方法，这两个方法是非继承的，也就是说是每个函数都自带的。</li>\n<li>apply()和call()方法的功能完全一样，都是把当前函数的this对象强行变成apply()或者call()方法的第一个参数。圆括号里从第二个参数开始才是原函数真正的参数。函数绑定了apply()或者call()方法后，立即执行。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">window.color=&apos;red&apos;;</div><div class=\"line\">var obj1=&#123; color:&apos;blue&apos;; &#125;</div><div class=\"line\">function sayColor( ) &#123;</div><div class=\"line\">    alert (this.color); //全局函数，this就是window</div><div class=\"line\">&#125;</div><div class=\"line\">sayColor();//   弹出red</div><div class=\"line\"></div><div class=\"line\">// 绑定call()或apply()后函数立即执行</div><div class=\"line\">sayColor.call(this);//弹出red,把原函数的this(window)变成了全局环境的this(window)，其实this本身没有改变，仍然是window</div><div class=\"line\">sayColor.call(window);//弹出red,把原函数的this(window)变成了window，其实this本身没有改变，仍然是window</div><div class=\"line\">sayColor.call(obj1);//弹出blue，把原函数的this(window)变成了obj1,而obj1.color就是blue</div></pre></td></tr></table></figure>\n<ul>\n<li>apply()和call()方法的区别：接受参数的方式不同。<ul>\n<li>apply()的第一个参数是要改变的this，第二个参数是保存真正参数的数组arguments，也可以是一个具体的由参数组成的数组。</li>\n<li>call()的第一个参数是要改变的this，从第二个开始，是原函数真正的参数，且传递的参数必须逐个列举出来</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">//以下两种apple()方法的传参方式等价</div><div class=\"line\">function_name.apply(this,arguments);</div><div class=\"line\">function_name.apply(this,[arg0,arg1,arg2,...]);</div><div class=\"line\"></div><div class=\"line\">//以下是call()方法的传参方式：</div><div class=\"line\">function_name.call(this,arg0,arg1,arg2,...);</div></pre></td></tr></table></figure>\n<ul>\n<li>bind()方法：作用类似与apply()和call()方法，但是不会立即执行。会返回一个函数，这个返回的函数的this值会被绑定为bind()的参数。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">window.color=&apos;red&apos;;</div><div class=\"line\">var obj1=&#123; color:&apos;blue&apos;; &#125;</div><div class=\"line\">function sayColor( ) &#123;</div><div class=\"line\">    alert (this.color); //全局函数，this就是window</div><div class=\"line\">&#125;</div><div class=\"line\">var objectSayColor=sayColor.bind(obj1); // 返回一个函数，这个函数的this就是bind()括号里的参数obj1</div><div class=\"line\">objectSayColor();       //执行这个返回函数，this.color就是obj1.color,弹出blue</div></pre></td></tr></table></figure>\n<h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3><p>见本博客中的《闭包小结》</p>\n<p>### </p>\n","excerpt":"","more":"<h3 id=\"什么是Function类型\"><a href=\"#什么是Function类型\" class=\"headerlink\" title=\"什么是Function类型\"></a>什么是Function类型</h3><p>之前已经说过，变量的值有基本类型值和引用类型值，而Function类型就属于引用类型值的一种。说白了，Function类型就是函数。由于引用类型都是对象，所以函数实际上也是对象。既然是对象，就和其他引用类型一样有自己的属性和方法。既然是引用类型的值，函数名实际上也是一个指向函数的指针，而不会与某个函数绑定。</p>\n<h3 id=\"没有重载\"><a href=\"#没有重载\" class=\"headerlink\" title=\"没有重载\"></a>没有重载</h3><p>因为函数名是指针，指向函数对象，所以当有几个函数名一模一样时，后面的会覆盖前面的函数，这个指针最终只指向最后一个函数对象。</p>\n<h3 id=\"定义函数的两种方法\"><a href=\"#定义函数的两种方法\" class=\"headerlink\" title=\"定义函数的两种方法\"></a>定义函数的两种方法</h3><ol>\n<li>函数声明，格式如下<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">function function_name(arg0,arg1,arg2,...) &#123;</div><div class=\"line\">        //函数体    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>函数声明的重要特性就<strong>是函数声明提升</strong>，意思是系统在执行代码时会先读取函数声明，这样就可以把函数声明放在调用它的语句之后了。</p>\n<ol>\n<li>函数表达式</li>\n</ol>\n<p>最常见的就是先创建一个匿名函数然后将这个匿名函数赋值给一个变量，变量名就是函数名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var function_name=function (arg0,arg1,arg2,...) &#123;</div><div class=\"line\">    //函数体 </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>匿名函数有一个重要特性就是，匿名函数的执行环境是全局环境，也就是说匿名函数里的this总是指window.</p>\n<h3 id=\"函数内部属性\"><a href=\"#函数内部属性\" class=\"headerlink\" title=\"函数内部属性\"></a>函数内部属性</h3><p>每个函数内部都有两个特殊的对象：arguments和this</p>\n<ul>\n<li><p>arguments对象：类似数组，包含着传入函数的所有参数。arguments有一个属性callee，该属性是一个指针，指向拥有这个arguments对象的函数，即指向正在执行的函数。<br>比较经典的例子就是递归函数。</p>\n<p>  递归函数是在一个函数通过名字调用自身的情况下构成的。在递归函数中，这样的做法会使函数的执行与函数名紧紧耦合在了一起，为了降低耦合度，一般用arguments.callee 来代替函数体中的函数名，arguments.callee是一个指向正在执行的函数的指针。这样即使执行函数的时候函数名发生了变化，也可以正常执行。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function factorial(num) &#123;</div><div class=\"line\">    if (num&lt;=1) &#123;</div><div class=\"line\">        return 1;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        return num*arguments.callee(num-1);     //用argument.callee代替函数名factorial</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>this对象：简单的说，当前方法或者函数属于谁，this就是谁。全局函数的this是window。</p>\n<h3 id=\"函数属性\"><a href=\"#函数属性\" class=\"headerlink\" title=\"函数属性\"></a>函数属性</h3><p>每个函数都包含两个属性：length和prototype。</p>\n</li>\n<li><p>length属性表示函数希望接受的命名参数的个数，即函数定义时圆括号里的参数个数。</p>\n</li>\n<li>prototype属性在创建自定义引用类型以及实现继承时极为重要，prototype属性的不可枚举的，使用for-in无法发现<h3 id=\"函数方法：\"><a href=\"#函数方法：\" class=\"headerlink\" title=\"函数方法：\"></a>函数方法：</h3>每个函数都包含apply()和call()方法，这两个方法是非继承的，也就是说是每个函数都自带的。</li>\n<li>apply()和call()方法的功能完全一样，都是把当前函数的this对象强行变成apply()或者call()方法的第一个参数。圆括号里从第二个参数开始才是原函数真正的参数。函数绑定了apply()或者call()方法后，立即执行。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">window.color=&apos;red&apos;;</div><div class=\"line\">var obj1=&#123; color:&apos;blue&apos;; &#125;</div><div class=\"line\">function sayColor( ) &#123;</div><div class=\"line\">    alert (this.color); //全局函数，this就是window</div><div class=\"line\">&#125;</div><div class=\"line\">sayColor();//   弹出red</div><div class=\"line\"></div><div class=\"line\">// 绑定call()或apply()后函数立即执行</div><div class=\"line\">sayColor.call(this);//弹出red,把原函数的this(window)变成了全局环境的this(window)，其实this本身没有改变，仍然是window</div><div class=\"line\">sayColor.call(window);//弹出red,把原函数的this(window)变成了window，其实this本身没有改变，仍然是window</div><div class=\"line\">sayColor.call(obj1);//弹出blue，把原函数的this(window)变成了obj1,而obj1.color就是blue</div></pre></td></tr></table></figure>\n<ul>\n<li>apply()和call()方法的区别：接受参数的方式不同。<ul>\n<li>apply()的第一个参数是要改变的this，第二个参数是保存真正参数的数组arguments，也可以是一个具体的由参数组成的数组。</li>\n<li>call()的第一个参数是要改变的this，从第二个开始，是原函数真正的参数，且传递的参数必须逐个列举出来</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">//以下两种apple()方法的传参方式等价</div><div class=\"line\">function_name.apply(this,arguments);</div><div class=\"line\">function_name.apply(this,[arg0,arg1,arg2,...]);</div><div class=\"line\"></div><div class=\"line\">//以下是call()方法的传参方式：</div><div class=\"line\">function_name.call(this,arg0,arg1,arg2,...);</div></pre></td></tr></table></figure>\n<ul>\n<li>bind()方法：作用类似与apply()和call()方法，但是不会立即执行。会返回一个函数，这个返回的函数的this值会被绑定为bind()的参数。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">window.color=&apos;red&apos;;</div><div class=\"line\">var obj1=&#123; color:&apos;blue&apos;; &#125;</div><div class=\"line\">function sayColor( ) &#123;</div><div class=\"line\">    alert (this.color); //全局函数，this就是window</div><div class=\"line\">&#125;</div><div class=\"line\">var objectSayColor=sayColor.bind(obj1); // 返回一个函数，这个函数的this就是bind()括号里的参数obj1</div><div class=\"line\">objectSayColor();       //执行这个返回函数，this.color就是obj1.color,弹出blue</div></pre></td></tr></table></figure>\n<h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3><p>见本博客中的《闭包小结》</p>\n<p>### </p>\n"},{"title":"圣杯布局和双飞翼布局","date":"2016-12-18T01:37:08.000Z","_content":"事实上，圣杯布局其实和双飞翼布局是一回事。它们实现的都是三栏布局，两边的盒子宽度固定，中间盒子自适应。它们实现的效果是一样的，差别在于其实现的思想。\n* 圣杯布局：\n\n具体实现方法：\n\n注意三个div的布局顺序，中间栏写在最前面，然后才是左右栏，且三栏都是左浮动。中间栏的宽度为100%，左栏与右栏都是采用margin负值定位的，margin-left为-100%，右侧栏也margin-left也是负值，大小为右栏本身的宽度。当中间栏的内容有很多的时候，内容会被左右栏覆盖一部分，这时候需要利用父级元素（包裹层）设置左右内边距padding的值，然后给左右两个盒子加一个相对定位，加了定位之后左栏的left等于父元素的padding-left加空隙，右栏的right等于父元素的padding-right加空隙。\n* 双飞翼布局：\n\n与圣杯布局相比，中间栏内层增加了一个div，这个div的内容才是真正的中间栏内容。去掉了左右栏的相对定位，去掉包裹层padding，以中间栏新增div的margin代替。\n\n\n具体实现方法：\n\n注意三个div的顺序，需要把中间栏div放最前面。首先，中间栏要使用双层标签。外层div宽度100%显示，并且浮动，内层div为真正的中间栏主体内容，左右margin分别等于左右两栏的宽度加间隙。左栏与右栏都是采用margin负值定位的，左栏左浮动，margin-left为-100%，由于前面的div宽度100%于浏览器，所以这里的-100%margin值正好使左栏div定位到了页面的左侧；右侧栏也是左浮动，其margin-left也是负值，大小为右栏本身的宽度\n\n\n### 总结\n虽然实现效果一样，但是双飞翼布局比圣杯布局仅仅增加多一个div就可以不用相对布局了，只用到了浮动和负边距。这种方式更加的简洁方便，而且没有用到相对定位，这就意味着在之后的布局中，双飞翼布局受到的局限更小。","source":"_posts/圣杯布局和双飞翼布局.md","raw":"---\ntitle: 圣杯布局和双飞翼布局\ndate: 2016-12-18 09:37:08\ntags: 学习心得\n---\n事实上，圣杯布局其实和双飞翼布局是一回事。它们实现的都是三栏布局，两边的盒子宽度固定，中间盒子自适应。它们实现的效果是一样的，差别在于其实现的思想。\n* 圣杯布局：\n\n具体实现方法：\n\n注意三个div的布局顺序，中间栏写在最前面，然后才是左右栏，且三栏都是左浮动。中间栏的宽度为100%，左栏与右栏都是采用margin负值定位的，margin-left为-100%，右侧栏也margin-left也是负值，大小为右栏本身的宽度。当中间栏的内容有很多的时候，内容会被左右栏覆盖一部分，这时候需要利用父级元素（包裹层）设置左右内边距padding的值，然后给左右两个盒子加一个相对定位，加了定位之后左栏的left等于父元素的padding-left加空隙，右栏的right等于父元素的padding-right加空隙。\n* 双飞翼布局：\n\n与圣杯布局相比，中间栏内层增加了一个div，这个div的内容才是真正的中间栏内容。去掉了左右栏的相对定位，去掉包裹层padding，以中间栏新增div的margin代替。\n\n\n具体实现方法：\n\n注意三个div的顺序，需要把中间栏div放最前面。首先，中间栏要使用双层标签。外层div宽度100%显示，并且浮动，内层div为真正的中间栏主体内容，左右margin分别等于左右两栏的宽度加间隙。左栏与右栏都是采用margin负值定位的，左栏左浮动，margin-left为-100%，由于前面的div宽度100%于浏览器，所以这里的-100%margin值正好使左栏div定位到了页面的左侧；右侧栏也是左浮动，其margin-left也是负值，大小为右栏本身的宽度\n\n\n### 总结\n虽然实现效果一样，但是双飞翼布局比圣杯布局仅仅增加多一个div就可以不用相对布局了，只用到了浮动和负边距。这种方式更加的简洁方便，而且没有用到相对定位，这就意味着在之后的布局中，双飞翼布局受到的局限更小。","slug":"圣杯布局和双飞翼布局","published":1,"updated":"2017-01-17T15:08:23.578Z","_id":"cix4spuyp0000ds518qllrck3","comments":1,"layout":"post","photos":[],"link":"","content":"<p>事实上，圣杯布局其实和双飞翼布局是一回事。它们实现的都是三栏布局，两边的盒子宽度固定，中间盒子自适应。它们实现的效果是一样的，差别在于其实现的思想。</p>\n<ul>\n<li>圣杯布局：</li>\n</ul>\n<p>具体实现方法：</p>\n<p>注意三个div的布局顺序，中间栏写在最前面，然后才是左右栏，且三栏都是左浮动。中间栏的宽度为100%，左栏与右栏都是采用margin负值定位的，margin-left为-100%，右侧栏也margin-left也是负值，大小为右栏本身的宽度。当中间栏的内容有很多的时候，内容会被左右栏覆盖一部分，这时候需要利用父级元素（包裹层）设置左右内边距padding的值，然后给左右两个盒子加一个相对定位，加了定位之后左栏的left等于父元素的padding-left加空隙，右栏的right等于父元素的padding-right加空隙。</p>\n<ul>\n<li>双飞翼布局：</li>\n</ul>\n<p>与圣杯布局相比，中间栏内层增加了一个div，这个div的内容才是真正的中间栏内容。去掉了左右栏的相对定位，去掉包裹层padding，以中间栏新增div的margin代替。</p>\n<p>具体实现方法：</p>\n<p>注意三个div的顺序，需要把中间栏div放最前面。首先，中间栏要使用双层标签。外层div宽度100%显示，并且浮动，内层div为真正的中间栏主体内容，左右margin分别等于左右两栏的宽度加间隙。左栏与右栏都是采用margin负值定位的，左栏左浮动，margin-left为-100%，由于前面的div宽度100%于浏览器，所以这里的-100%margin值正好使左栏div定位到了页面的左侧；右侧栏也是左浮动，其margin-left也是负值，大小为右栏本身的宽度</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>虽然实现效果一样，但是双飞翼布局比圣杯布局仅仅增加多一个div就可以不用相对布局了，只用到了浮动和负边距。这种方式更加的简洁方便，而且没有用到相对定位，这就意味着在之后的布局中，双飞翼布局受到的局限更小。</p>\n","excerpt":"","more":"<p>事实上，圣杯布局其实和双飞翼布局是一回事。它们实现的都是三栏布局，两边的盒子宽度固定，中间盒子自适应。它们实现的效果是一样的，差别在于其实现的思想。</p>\n<ul>\n<li>圣杯布局：</li>\n</ul>\n<p>具体实现方法：</p>\n<p>注意三个div的布局顺序，中间栏写在最前面，然后才是左右栏，且三栏都是左浮动。中间栏的宽度为100%，左栏与右栏都是采用margin负值定位的，margin-left为-100%，右侧栏也margin-left也是负值，大小为右栏本身的宽度。当中间栏的内容有很多的时候，内容会被左右栏覆盖一部分，这时候需要利用父级元素（包裹层）设置左右内边距padding的值，然后给左右两个盒子加一个相对定位，加了定位之后左栏的left等于父元素的padding-left加空隙，右栏的right等于父元素的padding-right加空隙。</p>\n<ul>\n<li>双飞翼布局：</li>\n</ul>\n<p>与圣杯布局相比，中间栏内层增加了一个div，这个div的内容才是真正的中间栏内容。去掉了左右栏的相对定位，去掉包裹层padding，以中间栏新增div的margin代替。</p>\n<p>具体实现方法：</p>\n<p>注意三个div的顺序，需要把中间栏div放最前面。首先，中间栏要使用双层标签。外层div宽度100%显示，并且浮动，内层div为真正的中间栏主体内容，左右margin分别等于左右两栏的宽度加间隙。左栏与右栏都是采用margin负值定位的，左栏左浮动，margin-left为-100%，由于前面的div宽度100%于浏览器，所以这里的-100%margin值正好使左栏div定位到了页面的左侧；右侧栏也是左浮动，其margin-left也是负值，大小为右栏本身的宽度</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>虽然实现效果一样，但是双飞翼布局比圣杯布局仅仅增加多一个div就可以不用相对布局了，只用到了浮动和负边距。这种方式更加的简洁方便，而且没有用到相对定位，这就意味着在之后的布局中，双飞翼布局受到的局限更小。</p>\n"},{"title":"基本类型值和引用类型值","date":"2016-12-22T01:37:08.000Z","_content":"### 测试量","source":"_posts/test.md","raw":"---\ntitle: 基本类型值和引用类型值\ndate: 2016-12-22 09:37:08\ntags: 学习心得\n---\n### 测试量","slug":"test","published":1,"updated":"2017-01-17T15:21:22.189Z","_id":"ciy1nokd50000hsnt4fnjdqca","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"测试量\"><a href=\"#测试量\" class=\"headerlink\" title=\"测试量\"></a>测试量</h3>","excerpt":"","more":"<h3 id=\"测试量\"><a href=\"#测试量\" class=\"headerlink\" title=\"测试量\"></a>测试量</h3>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ciwvcshlw00009o51smu1qt6s","tag_id":"ciwvcshma00029o51l1dkhin5","_id":"ciwvcshmh00059o51cqqjcybb"},{"post_id":"ciwvcshm700019o51safx46aw","tag_id":"ciwvcshma00029o51l1dkhin5","_id":"ciwvcshmj00079o51cclw4d6u"},{"post_id":"ciwvcshme00039o51jwt564rr","tag_id":"ciwvcshma00029o51l1dkhin5","_id":"ciwvcshmj00089o51vvg7hz15"},{"post_id":"ciwvcuh190000es51d17hzmml","tag_id":"ciwvcshma00029o51l1dkhin5","_id":"ciwvcuh1g0001es51udlrapue"},{"post_id":"ciwysvl5h00000s517y78kge1","tag_id":"ciwvcshma00029o51l1dkhin5","_id":"ciwysvl5q00010s513a3rf88q"},{"post_id":"cix1hurke0000oc51iijx95j1","tag_id":"ciwvcshma00029o51l1dkhin5","_id":"cix1hurl10001oc51ztrjo84c"},{"post_id":"cix1x8utu0000pk51hns8siou","tag_id":"ciwvcshma00029o51l1dkhin5","_id":"cix1x8uu30001pk51uqc2avr1"},{"post_id":"cix2oeylw00000g5165onlozo","tag_id":"ciwvcshma00029o51l1dkhin5","_id":"cix2oeymi00010g51g62onp0j"},{"post_id":"cix4spuyp0000ds518qllrck3","tag_id":"ciwvcshma00029o51l1dkhin5","_id":"cix4spuz40001ds51n3buzi8j"},{"post_id":"ciy1nokd50000hsnt4fnjdqca","tag_id":"ciwvcshma00029o51l1dkhin5","_id":"ciy1o70i700002wntdw4q9wng"}],"Tag":[{"name":"学习心得","_id":"ciwvcshma00029o51l1dkhin5"}]}}